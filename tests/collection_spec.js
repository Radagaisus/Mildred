// Generated by CoffeeScript 1.4.0
(function() {

  describe('Collection', function() {
    var collection, expectOrder;
    collection = null;
    beforeEach(function() {
      return collection = new Mildred.Collection;
    });
    afterEach(function() {
      return collection.dispose();
    });
    expectOrder = function(order) {
      var id, index, _i, _len, _results;
      _results = [];
      for (index = _i = 0, _len = order.length; _i < _len; index = ++_i) {
        id = order[index];
        _results.push(expect(collection.at(index).id).to.be(id));
      }
      return _results;
    };
    it('should serialize the models', function() {
      var actual, expected, model1, model2;
      model1 = new Mildred.Model({
        id: 1,
        foo: 'foo'
      });
      model2 = new Backbone.Model({
        id: 2,
        bar: 'bar'
      });
      collection = new Mildred.Collection([model1, model2]);
      expect(collection.serialize).to.be.a('function');
      actual = collection.serialize();
      expected = [
        {
          id: 1,
          foo: 'foo'
        }, {
          id: 2,
          bar: 'bar'
        }
      ];
      expect(actual.length).to.be(expected.length);
      expect(actual[0]).to.be.an('object');
      expect(actual[0].id).to.be(expected[0].id);
      expect(actual[0].foo).to.be(expected[0].foo);
      expect(actual[1]).to.be.an('object');
      expect(actual[1].id).to.be(expected[1].id);
      return expect(actual[1].foo).to.be(expected[1].foo);
    });
    return describe('Disposal', function() {
      it('should dispose itself correctly', function() {
        expect(collection.dispose).to.be.a('function');
        collection.dispose();
        expect(collection.length).to.be(0);
        expect(collection.disposed).to.be(true);
        if (Object.isFrozen) {
          return expect(Object.isFrozen(collection)).to.be(true);
        }
      });
      it('should fire a dispose event', function() {
        var disposeSpy;
        disposeSpy = sinon.spy();
        collection.on('dispose', disposeSpy);
        collection.dispose();
        return expect(disposeSpy).was.called();
      });
      it('should unsubscribe from Pub/Sub events', function() {
        var pubSubSpy;
        pubSubSpy = sinon.spy();
        collection.on('foo', pubSubSpy);
        collection.dispose();
        collection.trigger('foo');
        return expect(pubSubSpy).was.notCalled();
      });
      it('should remove all event handlers from itself', function() {
        var collectionBindSpy;
        collectionBindSpy = sinon.spy();
        collection.on('foo', collectionBindSpy);
        collection.dispose();
        collection.trigger('foo');
        return expect(collectionBindSpy).was.notCalled();
      });
      it('should unsubscribe from other events', function() {
        var model, spy;
        spy = sinon.spy();
        model = new Mildred.Model;
        collection.listenTo(model, 'foo', spy);
        collection.dispose();
        model.trigger('foo');
        return expect(spy).was.notCalled();
      });
      return it('should remove instance properties', function() {
        var prop, _i, _len, _ref, _results;
        collection.dispose();
        _ref = ['model', 'models', '_byId', '_byCid'];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          prop = _ref[_i];
          _results.push(expect(collection).not.to.have.own.property(prop));
        }
        return _results;
      });
    });
  });

}).call(this);
