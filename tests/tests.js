// Generated by CoffeeScript 1.4.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  describe('Application', function() {
    var app, getApp;
    app = null;
    getApp = function(noInit) {
      if (noInit) {
        return (function(_super) {

          __extends(_Class, _super);

          function _Class() {
            return _Class.__super__.constructor.apply(this, arguments);
          }

          _Class.prototype.initialize = function() {};

          return _Class;

        })(Mildred.Application);
      } else {
        return Mildred.Application;
      }
    };
    beforeEach(function() {
      return app = new (getApp(true));
    });
    afterEach(function() {
      return app.dispose();
    });
    it('should be a simple object', function() {
      expect(app).to.be.an('object');
      return expect(app).to.be.a(Mildred.Application);
    });
    it('should have initialize function', function() {
      expect(app.initialize).to.be.a('function');
      return app.initialize();
    });
    it('should create a dispatcher', function() {
      expect(app.initDispatcher).to.be.a('function');
      app.initDispatcher();
      return expect(app.dispatcher).to.be.a(Mildred.Dispatcher);
    });
    it('should create a layout', function() {
      expect(app.initLayout).to.be.a('function');
      app.initLayout();
      return expect(app.layout).to.be.a(Mildred.Layout);
    });
    it('should create a composer', function() {
      expect(app.initComposer).to.be.a('function');
      app.initComposer();
      return expect(app.composer).to.be.a(Mildred.Composer);
    });
    it('should create a router', function() {
      var passedMatch, routes, routesCalled;
      passedMatch = null;
      routesCalled = false;
      routes = function(match) {
        routesCalled = true;
        return passedMatch = match;
      };
      expect(app.initRouter).to.be.a('function');
      expect(app.initRouter.length).to.be(2);
      app.initRouter(routes, {
        root: '/',
        pushState: false
      });
      expect(app.router).to.be.a(Mildred.Router);
      expect(routesCalled).to.be(true);
      return expect(passedMatch).to.be.a('function');
    });
    it('should start Backbone.history with start()', function() {
      app.initRouter((function() {}), {
        root: '/',
        pushState: false
      });
      app.start();
      expect(Backbone.History.started).to.be(true);
      return Backbone.history.stop();
    });
    it('should throw an error on double-init', function() {
      return expect(function() {
        return (new (getApp(false))).initialize();
      }).to.throwError();
    });
    it('should dispose itself correctly', function() {
      var prop, _i, _len, _ref;
      expect(app.dispose).to.be.a('function');
      app.dispose();
      _ref = ['dispatcher', 'layout', 'router', 'composer'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        prop = _ref[_i];
        expect(app[prop]).to.be(void 0);
      }
      return expect(app.disposed).to.be(true);
    });
    return it('should be extendable', function() {
      var DerivedApplication, derivedApp;
      app.dispose();
      Backbone.history.stop();
      expect(Mildred.Application.extend).to.be.a('function');
      DerivedApplication = Mildred.Application.extend();
      derivedApp = new DerivedApplication();
      expect(derivedApp).to.be.a(Mildred.Application);
      return derivedApp.dispose();
    });
  });

  describe('SyncMachine', function() {
    var machine;
    machine = null;
    beforeEach(function() {
      machine = {};
      _.extend(machine, Backbone.Events);
      return _.extend(machine, Mildred.SyncMachine);
    });
    it('should change its state', function() {
      expect(machine.syncState()).to.be('unsynced');
      machine.beginSync();
      expect(machine.syncState()).to.be('syncing');
      machine.finishSync();
      expect(machine.syncState()).to.be('synced');
      machine.unsync();
      return expect(machine.syncState()).to.be('unsynced');
    });
    it('should emit sync events', function() {
      var stateChange, synced, syncing, unsynced;
      stateChange = sinon.spy();
      syncing = sinon.spy();
      synced = sinon.spy();
      unsynced = sinon.spy();
      machine.on('syncStateChange', stateChange);
      machine.on('syncing', syncing);
      machine.on('synced', synced);
      machine.on('unsynced', unsynced);
      machine.beginSync();
      expect(stateChange).was.calledOnce();
      expect(stateChange).was.calledWith(machine, 'syncing');
      expect(syncing).was.calledOnce();
      machine.finishSync();
      expect(stateChange).was.calledTwice();
      expect(stateChange).was.calledWith(machine, 'synced');
      return expect(synced).was.calledOnce();
    });
    it('should has shortcuts for checking sync state', function() {
      expect(machine.isUnsynced()).to.be(true);
      expect(machine.isSyncing()).to.be(false);
      expect(machine.isSynced()).to.be(false);
      machine.beginSync();
      expect(machine.isUnsynced()).to.be(false);
      expect(machine.isSyncing()).to.be(true);
      expect(machine.isSynced()).to.be(false);
      machine.finishSync();
      expect(machine.isUnsynced()).to.be(false);
      expect(machine.isSyncing()).to.be(false);
      return expect(machine.isSynced()).to.be(true);
    });
    it('should be able to abort sync', function() {
      machine.beginSync();
      machine.abortSync();
      return expect(machine.syncState()).to.be('unsynced');
    });
    return it('should has sync callbacks', function() {
      var synced, syncing, unsynced;
      syncing = sinon.spy();
      synced = sinon.spy();
      unsynced = sinon.spy();
      machine.syncing(syncing);
      machine.synced(synced);
      machine.unsynced(unsynced);
      machine.beginSync();
      expect(syncing).was.calledOnce();
      machine.finishSync();
      expect(synced).was.calledOnce();
      machine.unsync();
      return expect(unsynced).was.calledTwice();
    });
  });

  describe('View', function() {
    var ConfiguredTestView, TestView, collection, delay, model, renderCalled, setCollection, setModel, template, testbed, view;
    renderCalled = false;
    view = model = collection = null;
    template = '<p>content</p>';
    testbed = document.getElementById('testbed');
    Mildred.templateFunction = _.template;
    beforeEach(function() {
      renderCalled = false;
      return view = new TestView;
    });
    afterEach(function() {
      view.dispose();
      view = null;
      if (model) {
        if (typeof model.dispose === "function") {
          model.dispose();
        }
        model = null;
      }
      if (collection) {
        if (typeof collection.dispose === "function") {
          collection.dispose();
        }
        return collection = null;
      }
    });
    setModel = function() {
      model = new Mildred.Model({
        foo: 'foo',
        bar: 'bar'
      });
      return view.model = model;
    };
    setCollection = function() {
      collection = new Collection;
      return view.collection = collection;
    };
    delay = function(callback) {
      return window.setTimeout(callback, 40);
    };
    TestView = (function(_super) {

      __extends(TestView, _super);

      function TestView() {
        return TestView.__super__.constructor.apply(this, arguments);
      }

      TestView.prototype.id = 'test-view';

      TestView.prototype.initialize = function() {
        return TestView.__super__.initialize.apply(this, arguments);
      };

      TestView.prototype.getTemplateFunction = function() {
        return function() {
          return template;
        };
      };

      TestView.prototype.render = function() {
        TestView.__super__.render.apply(this, arguments);
        return renderCalled = true;
      };

      return TestView;

    })(Mildred.View);
    ConfiguredTestView = (function(_super) {

      __extends(ConfiguredTestView, _super);

      function ConfiguredTestView() {
        return ConfiguredTestView.__super__.constructor.apply(this, arguments);
      }

      ConfiguredTestView.prototype.autoRender = true;

      ConfiguredTestView.prototype.container = '#testbed';

      ConfiguredTestView.prototype.containerMethod = 'before';

      return ConfiguredTestView;

    })(TestView);
    it('should render', function() {
      var renderResult;
      expect(view.render).to.be.a('function');
      renderResult = view.render();
      return expect(renderResult).to.be(view);
    });
    it('should render a template', function() {
      var innerHTML, lowerCaseTemplate;
      view.render();
      innerHTML = view.$el.html().toLowerCase();
      lowerCaseTemplate = template.toLowerCase();
      return expect(innerHTML).to.be(lowerCaseTemplate);
    });
    it('should render automatically', function() {
      view = new TestView({
        autoRender: true
      });
      expect(renderCalled).to.be(true);
      return expect(view.$el.parent().length).to.be(0);
    });
    it('should not render without proper getTemplateFunction', function() {
      return expect(function() {
        return new Mildred.View({
          autoRender: true
        });
      }).to.throwError();
    });
    it('should attach itself to an element automatically', function() {
      view = new TestView({
        container: testbed
      });
      expect(renderCalled).to.be(false);
      expect(view.el.parentNode).to.be(null);
      view.render();
      return expect(view.el.parentNode).to.be(testbed);
    });
    it('should attach itself to a selector automatically', function() {
      view = new TestView({
        container: '#testbed'
      });
      view.render();
      return expect(view.el.parentNode).to.be(testbed);
    });
    it('should attach itself to a jQuery object automatically', function() {
      view = new TestView({
        container: $('#testbed')
      });
      view.render();
      return expect(view.el.parentNode).to.be(testbed);
    });
    it('should use the given attach method', function() {
      view = new TestView({
        container: testbed,
        containerMethod: 'after'
      });
      view.render();
      expect(view.el).to.be(testbed.nextSibling);
      return expect(view.el.parentNode).to.be(testbed.parentNode);
    });
    it('should consider autoRender, container and containerMethod properties', function() {
      view = new ConfiguredTestView();
      expect(renderCalled).to.be(true);
      expect(view.el).to.be(testbed.previousSibling);
      return expect(view.el.parentNode).to.be(testbed.parentNode);
    });
    it('should not attach itself more than once', function() {
      var spy;
      spy = sinon.spy($.prototype, 'append');
      view = new TestView({
        container: testbed
      });
      view.render();
      view.render();
      return expect(spy.calledOnce).to.be(true);
    });
    it('should not attach itself if autoAttach is false', function() {
      var NoAutoAttachView1, NoAutoAttachView2, check, view1, view2;
      NoAutoAttachView1 = (function(_super) {

        __extends(NoAutoAttachView1, _super);

        function NoAutoAttachView1() {
          return NoAutoAttachView1.__super__.constructor.apply(this, arguments);
        }

        NoAutoAttachView1.prototype.autoAttach = false;

        NoAutoAttachView1.prototype.autoRender = true;

        NoAutoAttachView1.prototype.container = testbed;

        NoAutoAttachView1.prototype.getTemplateFunction = TestView.prototype.getTemplateFunction;

        NoAutoAttachView1.prototype.attach = sinon.spy();

        return NoAutoAttachView1;

      })(Mildred.View);
      NoAutoAttachView2 = (function(_super) {

        __extends(NoAutoAttachView2, _super);

        function NoAutoAttachView2() {
          return NoAutoAttachView2.__super__.constructor.apply(this, arguments);
        }

        NoAutoAttachView2.prototype.autoAttach = false;

        NoAutoAttachView2.prototype.autoRender = true;

        NoAutoAttachView2.prototype.container = testbed;

        NoAutoAttachView2.prototype.attach = sinon.spy();

        return NoAutoAttachView2;

      })(TestView);
      check = function(view) {
        var parent;
        parent = view.el.parentNode;
        if (parent) {
          return expect(parent.nodeType).to.be(11);
        } else {
          return expect(parent).to.be(null);
        }
      };
      view1 = new NoAutoAttachView1;
      window.view1 = view1;
      expect(view1.attach).was.notCalled();
      check(view1);
      view2 = new NoAutoAttachView2;
      expect(view2.attach).was.notCalled();
      return check(view2);
    });
    it('should fire an addedToDOM event attching itself to the DOM', function() {
      var spy;
      view = new TestView({
        container: testbed
      });
      spy = sinon.spy();
      view.on('addedToDOM', spy);
      view.render();
      return expect(spy).was.called();
    });
    it('should register and remove user input event handlers', function() {
      var handler, p, spy;
      expect(view.delegate).to.be.a('function');
      expect(view.undelegate).to.be.a('function');
      spy = sinon.spy();
      handler = view.delegate('click', spy);
      expect(handler).to.be.a('function');
      view.$el.trigger('click');
      expect(spy).was.called();
      view.undelegate();
      view.$el.trigger('click');
      expect(spy.callCount).to.be(1);
      view.render();
      spy = sinon.spy();
      handler = view.delegate('click', 'p', spy);
      expect(handler).to.be.a('function');
      p = view.$('p');
      expect(p.length).to.be(1);
      p.trigger('click');
      expect(spy).was.called();
      expect(function() {
        return view.delegate(spy);
      }).to.throwError();
      view.undelegate();
      p.trigger('click');
      return expect(spy.callCount).to.be(1);
    });
    it('should register and remove multiple user input event handlers', function() {
      var handler, spy;
      spy = sinon.spy();
      handler = view.delegate('click keypress', spy);
      view.$el.trigger('click');
      view.$el.trigger('keypress');
      expect(spy).was.calledTwice();
      view.undelegate();
      view.$el.trigger('click');
      view.$el.trigger('keypress');
      return expect(spy).was.calledTwice();
    });
    it('should allow undelegating one event', function() {
      var handler, handler2, spy, spy2;
      spy = sinon.spy();
      spy2 = sinon.spy();
      handler = view.delegate('click keypress', spy);
      handler2 = view.delegate('focusout', spy2);
      view.$el.trigger('click');
      view.$el.trigger('keypress');
      expect(spy).was.calledTwice();
      expect(spy2).was.notCalled();
      view.undelegate('click keypress');
      view.$el.trigger('click');
      view.$el.trigger('keypress');
      view.$el.trigger('focusout');
      expect(spy).was.calledTwice();
      return expect(spy2).was.calledOnce();
    });
    it('should check delegate parameters', function() {
      expect(function() {
        return view.delegate(1, 2, 3);
      }).to.throwError();
      expect(function() {
        return view.delegate('click', 'foo');
      }).to.throwError();
      expect(function() {
        return view.delegate('click', 'foo', 'bar');
      }).to.throwError();
      expect(function() {
        return view.delegate('click', 123);
      }).to.throwError();
      expect(function() {
        return view.delegate('click', (function() {}), 123);
      }).to.throwError();
      return expect(function() {
        return view.delegate('click', 'foo', (function() {}), 'other');
      }).to.throwError();
    });
    it('should correct inheritance of events object', function(done) {
      var A, B, C, D, bcd, d;
      A = (function(_super) {

        __extends(A, _super);

        function A() {
          return A.__super__.constructor.apply(this, arguments);
        }

        A.prototype.autoRender = true;

        A.prototype.getTemplateFunction = function() {
          return function() {
            return '\
              <div id="a"></div>\
              <div id="b"></div>\
              <div id="c"></div>\
              <div id="d"></div>';
          };
        };

        A.prototype.events = {
          'click #a': 'a1Handler'
        };

        A.prototype.a1Handler = sinon.spy();

        A.prototype.click = function(index) {
          return this.$("#" + index).click();
        };

        return A;

      })(TestView);
      B = (function(_super) {

        __extends(B, _super);

        function B() {
          return B.__super__.constructor.apply(this, arguments);
        }

        B.prototype.events = {
          'click #a': 'a2Handler',
          'click #b': 'bHandler'
        };

        B.prototype.a2Handler = sinon.spy();

        B.prototype.bHandler = sinon.spy();

        return B;

      })(A);
      C = (function(_super) {

        __extends(C, _super);

        function C() {
          return C.__super__.constructor.apply(this, arguments);
        }

        C.prototype.events = {
          'click #a': 'a3Handler',
          'click #c': 'cHandler'
        };

        C.prototype.a3Handler = sinon.spy();

        C.prototype.cHandler = sinon.spy();

        return C;

      })(B);
      D = (function(_super) {

        __extends(D, _super);

        function D() {
          return D.__super__.constructor.apply(this, arguments);
        }

        D.prototype.events = {
          'click #a': 'a4Handler',
          'click #d': 'dHandler',
          'click': 'globalHandler'
        };

        D.prototype.a4Handler = sinon.spy();

        D.prototype.dHandler = sinon.spy();

        D.prototype.globalHandler = sinon.spy();

        return D;

      })(C);
      bcd = ['b', 'c', 'd'];
      d = new D;
      d.click('a');
      return delay(function() {
        var index, _i, _j, _len, _len1, _ref;
        _ref = _.range(1, 5);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          index = _ref[_i];
          expect(d["a" + index + "Handler"]).was.calledOnce();
        }
        for (_j = 0, _len1 = bcd.length; _j < _len1; _j++) {
          index = bcd[_j];
          expect(d["" + index + "Handler"]).was.notCalled();
          d.click(index);
        }
        return delay(function() {
          var _k, _len2;
          for (_k = 0, _len2 = bcd.length; _k < _len2; _k++) {
            index = bcd[_k];
            expect(d["" + index + "Handler"]).was.calledOnce();
          }
          expect(d.globalHandler.callCount).to.be(4);
          return done();
        });
      });
    });
    it('should throw an error when function is passed as second arg', function() {
      var E;
      return E = (function(_super) {

        __extends(E, _super);

        function E() {
          return E.__super__.constructor.apply(this, arguments);
        }

        E.prototype.events = function() {
          return expect(function() {
            return new E;
          }).to.throwError();
        };

        return E;

      })(TestView);
    });
    it('should add and return subviews', function() {
      var subview, subview2;
      expect(view.subview).to.be.a('function');
      subview = new Mildred.View();
      view.subview('fooSubview', subview);
      expect(view.subview('fooSubview')).to.be(subview);
      expect(view.subviews.length).to.be(1);
      subview2 = new Mildred.View();
      view.subview('fooSubview', subview2);
      expect(view.subview('fooSubview')).to.be(subview2);
      return expect(view.subviews.length).to.be(1);
    });
    it('should remove subviews', function() {
      var subview;
      expect(view.removeSubview).to.be.a('function');
      subview = new Mildred.View();
      view.subview('fooSubview', subview);
      view.removeSubview('fooSubview');
      expect(typeof view.subview('fooSubview')).to.be('undefined');
      expect(view.subviews.length).to.be(0);
      subview = new Mildred.View();
      view.subview('barSubview', subview);
      view.removeSubview(subview);
      expect(typeof view.subview('barSubview')).to.be('undefined');
      expect(view.subviews.length).to.be(0);
      view.removeSubview('');
      return expect(view.subviews.length).to.be(0);
    });
    it('should return empty template data without a model', function() {
      var templateData;
      templateData = view.getTemplateData();
      expect(templateData).to.be.an('object');
      return expect(_.isEmpty(templateData)).to.be(true);
    });
    it('should return proper template data for a Chaplin model', function() {
      var templateData;
      setModel();
      templateData = view.getTemplateData();
      expect(templateData).to.be.an('object');
      expect(templateData.foo).to.be('foo');
      return expect(templateData.bar).to.be('bar');
    });
    it('should return template data that protects the model', function() {
      var templateData;
      setModel();
      templateData = view.getTemplateData();
      templateData.qux = 'qux';
      return expect(model.get('qux')).to.be(void 0);
    });
    it('should return proper template data for a Backbone model', function() {
      var templateData;
      model = new Backbone.Model({
        foo: 'foo',
        bar: 'bar'
      });
      view.model = model;
      templateData = view.getTemplateData();
      expect(templateData).to.be.an('object');
      expect(templateData.foo).to.be('foo');
      return expect(templateData.bar).to.be('bar');
    });
    it('should return proper template data for Chaplin collections', function() {
      var data, items, model1, model2;
      model1 = new Mildred.Model({
        foo: 'foo'
      });
      model2 = new Mildred.Model({
        bar: 'bar'
      });
      collection = new Mildred.Collection([model1, model2]);
      view.collection = collection;
      data = view.getTemplateData();
      expect(data).to.be.an('object');
      expect(data).to.only.have.keys('items', 'length');
      expect(data.length).to.be(2);
      items = data.items;
      expect(items).to.be.an('array');
      expect(data.length).to.be(items.length);
      expect(items[0]).to.be.an('object');
      expect(items[0].foo).to.be('foo');
      expect(items[1]).to.be.an('object');
      return expect(items[1].bar).to.be('bar');
    });
    it('should return proper template data for Backbone collections', function() {
      var data, items, model1, model2;
      model1 = new Backbone.Model({
        foo: 'foo'
      });
      model2 = new Backbone.Model({
        bar: 'bar'
      });
      collection = new Backbone.Collection([model1, model2]);
      view.collection = collection;
      data = view.getTemplateData();
      expect(data).to.be.an('object');
      expect(data).to.only.have.keys('items', 'length');
      expect(data.length).to.be(2);
      items = data.items;
      expect(items).to.be.an('array');
      expect(items.length).to.be(2);
      expect(items[0]).to.be.an('object');
      expect(items[0].foo).to.be('foo');
      expect(items[1]).to.be.an('object');
      return expect(items[1].bar).to.be('bar');
    });
    it('should add the SyncMachine state to the template data', function() {
      var templateData;
      setModel();
      _.extend(model, Mildred.SyncMachine);
      templateData = view.getTemplateData();
      expect(templateData.synced).to.be(false);
      model.beginSync();
      model.finishSync();
      templateData = view.getTemplateData();
      return expect(templateData.synced).to.be(true);
    });
    it('should not cover existing SyncMachine properties', function() {
      var templateData;
      setModel();
      _.extend(model, Mildred.SyncMachine);
      model.set({
        syncState: 'foo',
        synced: 'bar'
      });
      templateData = view.getTemplateData();
      expect(templateData.syncState).to.be('foo');
      return expect(templateData.synced).to.be('bar');
    });
    describe('Events', function() {
      var EventedView, EventedViewParent;
      EventedViewParent = (function(_super) {

        __extends(EventedViewParent, _super);

        function EventedViewParent() {
          return EventedViewParent.__super__.constructor.apply(this, arguments);
        }

        EventedViewParent.prototype.listen = {
          'ns:a': 'a1Handler',
          'ns:b': function() {
            return this.b1Handler.apply(this, arguments);
          },
          'change:a model': 'a1Handler',
          'change:b model': 'b1Handler',
          'reset collection': 'a1Handler',
          'custom collection': 'b1Handler',
          'ns:a mediator': 'a1Handler',
          'ns:b mediator': 'b1Handler'
        };

        EventedViewParent.prototype.initialize = function() {
          EventedViewParent.__super__.initialize.apply(this, arguments);
          this.a1Handler = sinon.spy();
          return this.b1Handler = sinon.spy();
        };

        return EventedViewParent;

      })(Mildred.View);
      EventedView = (function(_super) {

        __extends(EventedView, _super);

        function EventedView() {
          return EventedView.__super__.constructor.apply(this, arguments);
        }

        EventedView.prototype.listen = {
          'ns:a': 'a2Handler',
          'ns:b': function() {
            return this.b2Handler.apply(this, arguments);
          },
          'change:a model': 'a2Handler',
          'change:b model': 'b2Handler',
          'reset collection': 'a2Handler',
          'custom collection': 'b2Handler',
          'ns:a mediator': 'a2Handler',
          'ns:b mediator': 'b2Handler'
        };

        EventedView.prototype.initialize = function() {
          EventedView.__super__.initialize.apply(this, arguments);
          this.a2Handler = sinon.spy();
          return this.b2Handler = sinon.spy();
        };

        return EventedView;

      })(EventedViewParent);
      it('should bind to own events declaratively', function() {
        view = new EventedView({
          model: new Mildred.Model()
        });
        expect(view.a1Handler).was.notCalled();
        expect(view.a2Handler).was.notCalled();
        expect(view.b1Handler).was.notCalled();
        expect(view.b2Handler).was.notCalled();
        view.trigger('ns:a');
        expect(view.a1Handler).was.calledOnce();
        expect(view.a2Handler).was.calledOnce();
        expect(view.b1Handler).was.notCalled();
        expect(view.b2Handler).was.notCalled();
        view.trigger('ns:b');
        expect(view.a1Handler).was.calledOnce();
        expect(view.a2Handler).was.calledOnce();
        expect(view.b1Handler).was.calledOnce();
        return expect(view.b2Handler).was.calledOnce();
      });
      it('should bind to model events declaratively', function() {
        model = new Mildred.Model();
        view = new EventedView({
          model: model
        });
        expect(view.a1Handler).was.notCalled();
        expect(view.a2Handler).was.notCalled();
        expect(view.b1Handler).was.notCalled();
        expect(view.b2Handler).was.notCalled();
        model.set('a', 1);
        expect(view.a1Handler).was.calledOnce();
        expect(view.a2Handler).was.calledOnce();
        expect(view.b1Handler).was.notCalled();
        expect(view.b2Handler).was.notCalled();
        model.set('b', 2);
        expect(view.a1Handler).was.calledOnce();
        expect(view.a2Handler).was.calledOnce();
        expect(view.b1Handler).was.calledOnce();
        return expect(view.b2Handler).was.calledOnce();
      });
      it('should bind to collection events declaratively', function() {
        collection = new Mildred.Collection();
        view = new EventedView({
          collection: collection
        });
        expect(view.a1Handler).was.notCalled();
        expect(view.a2Handler).was.notCalled();
        expect(view.b1Handler).was.notCalled();
        expect(view.b2Handler).was.notCalled();
        collection.reset([
          {
            a: 1
          }
        ]);
        expect(view.a1Handler).was.calledOnce();
        expect(view.a2Handler).was.calledOnce();
        expect(view.b1Handler).was.notCalled();
        expect(view.b2Handler).was.notCalled();
        collection.trigger('custom');
        expect(view.a1Handler).was.calledOnce();
        expect(view.a2Handler).was.calledOnce();
        expect(view.b1Handler).was.calledOnce();
        return expect(view.b2Handler).was.calledOnce();
      });
      it('should throw an error when corresponding method doesn’t exist', function() {
        var Error2View, ErrorView;
        ErrorView = (function(_super) {

          __extends(ErrorView, _super);

          function ErrorView() {
            return ErrorView.__super__.constructor.apply(this, arguments);
          }

          ErrorView.prototype.listen = {
            'stuff': 'stuff'
          };

          return ErrorView;

        })(Mildred.View);
        Error2View = (function(_super) {

          __extends(Error2View, _super);

          function Error2View() {
            return Error2View.__super__.constructor.apply(this, arguments);
          }

          Error2View.prototype.events = {
            'stuff': 'stuff'
          };

          return Error2View;

        })(ConfiguredTestView);
        expect(function() {
          return new ErrorView;
        }).to.throwError();
        return expect(function() {
          return new Error2View;
        }).to.throwError();
      });
      it('should allow passing params to delegateEvents', function(done) {
        var spy;
        spy = sinon.spy();
        view = new ConfiguredTestView;
        view.delegateEvents({
          'click p': spy
        });
        view.$('p').click();
        return delay(function() {
          expect(spy).was.calledOnce();
          return done();
        });
      });
      it('should register event handlers on the document declaratively', function() {
        var PreservedView, el, spy1, spy2;
        spy1 = sinon.spy();
        spy2 = sinon.spy();
        PreservedView = (function(_super) {

          __extends(PreservedView, _super);

          function PreservedView() {
            return PreservedView.__super__.constructor.apply(this, arguments);
          }

          PreservedView.prototype.autoRender = true;

          PreservedView.prototype.keepElement = true;

          PreservedView.prototype.events = {
            'click p': 'testClickHandler',
            click: spy2
          };

          PreservedView.prototype.testClickHandler = spy1;

          return PreservedView;

        })(TestView);
        view = new PreservedView;
        el = view.$('p');
        el.click();
        expect(spy1).was.called();
        expect(spy2).was.called();
        view.dispose();
        el.click();
        expect(spy1.callCount).to.be(1);
        return expect(spy2.callCount).to.be(1);
      });
      return it('should register event handlers on the document programatically', function() {
        var PreservedView, el, spy1, spy2;
        spy1 = sinon.spy();
        spy2 = sinon.spy();
        PreservedView = (function(_super) {

          __extends(PreservedView, _super);

          function PreservedView() {
            return PreservedView.__super__.constructor.apply(this, arguments);
          }

          PreservedView.prototype.autoRender = true;

          PreservedView.prototype.keepElement = true;

          return PreservedView;

        })(TestView);
        view = new PreservedView;
        view.testClickHandler = spy1;
        view.delegateEvents({
          'click p': 'testClickHandler',
          click: spy2
        });
        el = view.$('p');
        el.click();
        expect(spy1).was.called();
        expect(spy2).was.called();
        view.undelegateEvents();
        el.click();
        expect(spy1.callCount).to.be(1);
        return expect(spy2.callCount).to.be(1);
      });
    });
    it('should pass model attributes to the template function', function() {
      var passedTemplateData, templateData, templateFunc;
      setModel();
      sinon.spy(view, 'getTemplateData');
      passedTemplateData = null;
      templateFunc = sinon.stub().returns(template);
      sinon.stub(view, 'getTemplateFunction').returns(templateFunc);
      view.render();
      expect(view.getTemplateFunction).was.called();
      expect(view.getTemplateData).was.called();
      expect(templateFunc).was.called();
      templateData = templateFunc.lastCall.args[0];
      expect(templateData).to.be.an('object');
      expect(templateData.foo).to.be('foo');
      return expect(templateData.bar).to.be('bar');
    });
    return describe('Disposal', function() {
      it('should dispose itself correctly', function() {
        expect(view.dispose).to.be.a('function');
        view.dispose();
        return expect(view.disposed).to.be(true);
      });
      it('should remove itself from the DOM', function() {
        view.$el.attr('id', 'disposed-view').appendTo(document.body);
        expect($('#disposed-view').length).to.be(1);
        view.dispose();
        return expect($('#disposed-view').length).to.be(0);
      });
      it('should call Backbone.View#remove', function() {
        sinon.spy(view, 'remove');
        view.dispose();
        return expect(view.remove).was.called();
      });
      it('should dispose subviews', function() {
        var subview;
        subview = new Mildred.View();
        sinon.spy(subview, 'dispose');
        view.subview('foo', subview);
        view.dispose();
        expect(subview.disposed).to.be(true);
        return expect(subview.dispose).was.called();
      });
      it('should unsubscribe from Pub/Sub events', function() {
        var spy;
        spy = sinon.spy();
        view.on('foo', spy);
        view.dispose();
        view.trigger('foo');
        return expect(spy).was.notCalled();
      });
      it('should unsubscribe from model events', function() {
        var spy;
        setModel();
        spy = sinon.spy();
        view.listenTo(view.model, 'foo', spy);
        view.dispose();
        model.trigger('foo');
        return expect(spy).was.notCalled();
      });
      it('should remove all event handlers from itself', function() {
        var spy;
        spy = sinon.spy();
        view.on('foo', spy);
        view.dispose();
        view.trigger('foo');
        return expect(spy).was.notCalled();
      });
      it('should remove instance properties', function() {
        var prop, properties, _i, _len, _results;
        view.dispose();
        properties = ['el', '$el', 'options', 'model', 'collection', 'subviews', 'subviewsByName', '_callbacks'];
        _results = [];
        for (_i = 0, _len = properties.length; _i < _len; _i++) {
          prop = properties[_i];
          _results.push(expect(view).not.to.have.own.property(prop));
        }
        return _results;
      });
      it('should dispose itself when the model is disposed', function() {
        model = new Mildred.Model();
        view = new TestView({
          model: model
        });
        model.dispose();
        expect(model.disposed).to.be(true);
        return expect(view.disposed).to.be(true);
      });
      it('should dispose itself when the collection is disposed', function() {
        collection = new Mildred.Collection();
        view = new TestView({
          collection: collection
        });
        collection.dispose();
        expect(collection.disposed).to.be(true);
        return expect(view.disposed).to.be(true);
      });
      it('should not dispose itself when the collection model is disposed', function() {
        collection = new Mildred.Collection([
          {
            a: 1
          }, {
            a: 2
          }, {
            a: 3
          }
        ]);
        view = new TestView({
          collection: collection
        });
        collection.at(0).dispose();
        expect(collection.disposed).to.be(false);
        return expect(view.disposed).to.be(false);
      });
      it('should not render when disposed given render wasn’t overridden', function() {
        var renderResult;
        view = new Mildred.View();
        view.getTemplateFunction = TestView.prototype.getTemplateFunction;
        sinon.spy(view, 'attach');
        renderResult = view.render();
        expect(renderResult).to.be(view);
        view.dispose();
        renderResult = view.render();
        expect(renderResult).to.be(false);
        return expect(view.attach.callCount).to.be(1);
      });
      return it('should not render when disposed given render was overridden', function() {
        var renderResult;
        view = new TestView({
          container: '#testbed'
        });
        sinon.spy(view, 'attach');
        renderResult = view.render();
        expect(renderResult).to.be(view);
        expect(view.attach.callCount).to.be(1);
        expect(renderCalled).to.be(true);
        expect(view.el.parentNode).to.be(testbed);
        view.dispose();
        renderResult = view.render();
        expect(renderResult).to.be(false);
        expect(renderCalled).to.be(true);
        expect($(testbed).children().length).to.be(0);
        return expect(view.attach.callCount).to.be(1);
      });
    });
  });

  describe('CollectionView', function() {
    var ItemView, TestCollectionView, addOne, addThree, basicSetup, collection, collectionView, createCollection, createCollectionView, fillCollection, freshModels, getAllChildren, getViewChildren, oneModel, threeModels, viewsMatchCollection;
    collection = null;
    collectionView = null;
    ItemView = (function(_super) {

      __extends(ItemView, _super);

      function ItemView() {
        return ItemView.__super__.constructor.apply(this, arguments);
      }

      ItemView.prototype.tagName = 'li';

      ItemView.prototype.initialize = function() {
        ItemView.__super__.initialize.apply(this, arguments);
        return this.$el.attr({
          id: this.model.id,
          cid: this.model.cid
        });
      };

      ItemView.prototype.templateFunction = function(templateData) {
        return templateData.title;
      };

      ItemView.prototype.getTemplateFunction = function() {
        return this.templateFunction;
      };

      return ItemView;

    })(Mildred.View);
    TestCollectionView = (function(_super) {

      __extends(TestCollectionView, _super);

      function TestCollectionView() {
        return TestCollectionView.__super__.constructor.apply(this, arguments);
      }

      TestCollectionView.prototype.tagName = 'ul';

      TestCollectionView.prototype.animationDuration = 0;

      TestCollectionView.prototype.itemView = ItemView;

      return TestCollectionView;

    })(Mildred.CollectionView);
    freshModels = function() {
      var code, _i, _results;
      _results = [];
      for (code = _i = 65; _i <= 90; code = ++_i) {
        _results.push({
          id: String.fromCharCode(code),
          title: String(Math.random())
        });
      }
      return _results;
    };
    fillCollection = function() {
      return collection.reset(freshModels());
    };
    oneModel = function() {
      return new Mildred.Model({
        id: 'one',
        title: 'one'
      });
    };
    addOne = function() {
      var model;
      model = oneModel();
      collection.add(model);
      return model;
    };
    threeModels = function() {
      var model1, model2, model3;
      model1 = new Mildred.Model({
        id: 'new1',
        title: 'new'
      });
      model2 = new Mildred.Model({
        id: 'new2',
        title: 'new'
      });
      model3 = new Mildred.Model({
        id: 'new3',
        title: 'new'
      });
      return [model1, model2, model3];
    };
    addThree = function() {
      var models;
      models = threeModels();
      collection.add(models[0], {
        at: 0
      });
      collection.add(models[1], {
        at: 10
      });
      collection.add(models[2]);
      return models;
    };
    getViewChildren = function() {
      return collectionView.$list.children(collectionView.itemSelector);
    };
    getAllChildren = function() {
      return collectionView.$el.children();
    };
    viewsMatchCollection = function() {
      var children;
      children = getViewChildren();
      expect(children.length).to.be(collection.length);
      return collection.forEach(function(model, index) {
        var $el, actualId, actualTitle, expectedId, expectedTitle;
        $el = children.eq(index);
        expectedId = String(model.id);
        actualId = $el.attr('id');
        expect(actualId).to.be(expectedId);
        expectedTitle = model.get('title');
        if (expectedTitle != null) {
          actualTitle = $el.text();
          return expect(actualTitle).to.be(expectedTitle);
        }
      });
    };
    createCollection = function(models) {
      return collection = new Mildred.Collection(models || freshModels());
    };
    createCollectionView = function() {
      return collectionView = new TestCollectionView({
        collection: collection
      });
    };
    basicSetup = function(models) {
      createCollection(models);
      return createCollectionView();
    };
    beforeEach(function() {});
    afterEach(function() {
      if (collectionView != null) {
        collectionView.dispose();
      }
      if (collection != null) {
        collection.dispose();
      }
      return collectionView = collection = null;
    });
    describe('Basic item rendering', function() {
      it('should render item views', function() {
        basicSetup();
        return viewsMatchCollection();
      });
      it('should call a custom initItemView method', function() {
        var CustomViewCollectionView, initItemView;
        CustomViewCollectionView = (function(_super) {

          __extends(CustomViewCollectionView, _super);

          function CustomViewCollectionView() {
            return CustomViewCollectionView.__super__.constructor.apply(this, arguments);
          }

          CustomViewCollectionView.prototype.tagName = 'ul';

          CustomViewCollectionView.prototype.animationDuration = 0;

          CustomViewCollectionView.prototype.initItemView = function(model) {
            return new ItemView({
              model: model
            });
          };

          return CustomViewCollectionView;

        })(Mildred.CollectionView);
        createCollection();
        initItemView = sinon.spy(CustomViewCollectionView.prototype, 'initItemView');
        collectionView = new CustomViewCollectionView({
          collection: collection
        });
        viewsMatchCollection();
        expect(initItemView.callCount).to.be(collection.length);
        return initItemView.restore();
      });
      it('should respect the autoRender and renderItems options', function() {
        var children, renderAllItemsSpy, renderSpy;
        createCollection();
        renderSpy = sinon.spy(Mildred.CollectionView.prototype, 'render');
        renderAllItemsSpy = sinon.spy(Mildred.CollectionView.prototype, 'renderAllItems');
        collectionView = new TestCollectionView({
          collection: collection,
          autoRender: false,
          renderItems: false
        });
        expect(renderSpy).was.notCalled();
        expect(renderAllItemsSpy).was.notCalled();
        children = getAllChildren();
        expect(children.length).to.be(0);
        expect(_.has(collectionView, '$list')).to.be(false);
        collectionView.render();
        expect(collectionView.$list).to.be.a(jQuery);
        expect(collectionView.$list.length).to.be(1);
        collectionView.renderAllItems();
        viewsMatchCollection();
        renderSpy.restore();
        return renderAllItemsSpy.restore();
      });
      return it('should init subviews with disabled autoRender', function() {
        var AutoRenderCollectionView, AutoRenderItemView, calls;
        calls = 0;
        AutoRenderItemView = (function(_super) {

          __extends(AutoRenderItemView, _super);

          function AutoRenderItemView() {
            return AutoRenderItemView.__super__.constructor.apply(this, arguments);
          }

          AutoRenderItemView.prototype.autoRender = false;

          AutoRenderItemView.prototype.render = function() {
            AutoRenderItemView.__super__.render.apply(this, arguments);
            return calls += 1;
          };

          return AutoRenderItemView;

        })(ItemView);
        AutoRenderCollectionView = (function(_super) {

          __extends(AutoRenderCollectionView, _super);

          function AutoRenderCollectionView() {
            return AutoRenderCollectionView.__super__.constructor.apply(this, arguments);
          }

          AutoRenderCollectionView.prototype.itemView = AutoRenderItemView;

          return AutoRenderCollectionView;

        })(Mildred.CollectionView);
        createCollection();
        collectionView = new AutoRenderCollectionView({
          collection: collection
        });
        return expect(calls).to.be(collection.length);
      });
    });
    describe('Basic collection change behavior', function() {
      it('should add views when collection items are added', function() {
        basicSetup();
        addThree();
        return viewsMatchCollection();
      });
      it('should remove views when collection items are removed', function() {
        var models;
        basicSetup();
        models = addThree();
        collection.remove(models);
        return viewsMatchCollection();
      });
      return it('should remove all views when collection is emptied', function() {
        var children;
        basicSetup();
        collection.reset();
        children = getViewChildren();
        return expect(children.length).to.be(0);
      });
    });
    describe('Sorting', function() {
      return it('should reorder views on sort', function() {
        var sortAndMatch;
        basicSetup(threeModels());
        sortAndMatch = function(comparator) {
          collection.comparator = comparator;
          collection.sort();
          return viewsMatchCollection();
        };
        sortAndMatch(function(a, b) {
          return a.id > b.id;
        });
        return sortAndMatch(function(a, b) {
          return a.id < b.id;
        });
      });
    });
    describe('Complex Reset and Set behavior', function() {
      it('should reuse views on reset', function() {
        var model1, model2, newView1, view1, view2;
        basicSetup();
        expect(collectionView.getItemViews()).to.be.an('object');
        model1 = collection.at(0);
        view1 = collectionView.subview("itemView:" + model1.cid);
        expect(view1).to.be.an(ItemView);
        model2 = collection.at(1);
        view2 = collectionView.subview("itemView:" + model2.cid);
        expect(view2).to.be.an(ItemView);
        collection.reset(model1);
        expect(view1.disposed).to.be(false);
        expect(view2.disposed).to.be(true);
        newView1 = collectionView.subview("itemView:" + model1.cid);
        return expect(newView1).to.be(view1);
      });
      it('should insert views in the right order on reset', function() {
        var baseResetAndCheck, full, m0, m1, m2, m3, m4, m5, makeResetAndCheck, resetAndCheck;
        basicSetup();
        m0 = new Mildred.Model({
          id: 0
        });
        m1 = new Mildred.Model({
          id: 1
        });
        m2 = new Mildred.Model({
          id: 2
        });
        m3 = new Mildred.Model({
          id: 3
        });
        m4 = new Mildred.Model({
          id: 4
        });
        m5 = new Mildred.Model({
          id: 5
        });
        baseResetAndCheck = function(models1, models2) {
          collection.reset(models1);
          collection.reset(models2);
          return viewsMatchCollection();
        };
        makeResetAndCheck = function(models1) {
          return function(models2) {
            return baseResetAndCheck(models1, models2);
          };
        };
        full = [m0, m1, m2, m3, m4, m5];
        resetAndCheck = makeResetAndCheck(full);
        resetAndCheck([m1, m2, m3, m4, m5]);
        resetAndCheck([m0, m1, m2, m3, m4]);
        resetAndCheck([m0, m1, m4, m5]);
        resetAndCheck([m1, m3, m5]);
        resetAndCheck([m0, m2, m4]);
        resetAndCheck = makeResetAndCheck([m1, m2, m3]);
        resetAndCheck([m0, m1, m2, m3]);
        resetAndCheck([m1, m2, m3, m4]);
        baseResetAndCheck([m0, m1, m4, m5], full);
        baseResetAndCheck([m1, m3, m5], full);
        baseResetAndCheck([m0, m2, m4], full);
        baseResetAndCheck([m0, m2, m3], [m1, m2, m3]);
        baseResetAndCheck([m0, m2, m5], [m0, m3, m5]);
        baseResetAndCheck([m0, m2, m5], [m0, m3, m5]);
        baseResetAndCheck([m0, m2, m3, m5], [m0, m3, m4, m5]);
        baseResetAndCheck([m0, m1, m2, m3], [m0, m2, m1, m3]);
        return baseResetAndCheck([m0, m1, m2], [m3, m4, m5]);
      });
      return it('should insert views in the right order on set', function() {
        var baseSetAndCheck, full, m0, m1, m2, m3, m4, m5, makeSetAndCheck, setAndCheck;
        basicSetup();
        m0 = new Mildred.Model({
          id: 0
        });
        m1 = new Mildred.Model({
          id: 1
        });
        m2 = new Mildred.Model({
          id: 2
        });
        m3 = new Mildred.Model({
          id: 3
        });
        m4 = new Mildred.Model({
          id: 4
        });
        m5 = new Mildred.Model({
          id: 5
        });
        baseSetAndCheck = function(models1, models2) {
          collection.reset(models1);
          collection.set(models2);
          return viewsMatchCollection();
        };
        makeSetAndCheck = function(setup) {
          return function(models) {
            return baseSetAndCheck(setup, models);
          };
        };
        full = [m0, m1, m2, m3, m4, m5];
        setAndCheck = makeSetAndCheck(full);
        setAndCheck([m1, m2, m3, m4, m5]);
        setAndCheck([m0, m1, m2, m3, m4]);
        setAndCheck([m0, m1, m4, m5]);
        setAndCheck([m1, m3, m5]);
        setAndCheck([m0, m2, m4]);
        setAndCheck = makeSetAndCheck([m1, m2, m3]);
        setAndCheck([m0, m1, m2, m3]);
        setAndCheck([m1, m2, m3, m4]);
        baseSetAndCheck([m0, m1, m4, m5], full);
        baseSetAndCheck([m1, m3, m5], full);
        baseSetAndCheck([m0, m2, m4], full);
        baseSetAndCheck([m0, m2, m3], [m1, m2, m3]);
        baseSetAndCheck([m0, m2, m5], [m0, m3, m5]);
        baseSetAndCheck([m0, m2, m5], [m0, m3, m5]);
        baseSetAndCheck([m0, m2, m3, m5], [m0, m3, m4, m5]);
        baseSetAndCheck([m0, m1, m2, m3], [m0, m2, m1, m3]);
        return baseSetAndCheck([m0, m1, m2], [m3, m4, m5]);
      });
    });
    describe('Visible items', function() {
      it('should have a visibleItems array', function() {
        var visibleItems;
        basicSetup();
        visibleItems = collectionView.visibleItems;
        expect(visibleItems).to.be.an('array');
        expect(visibleItems.length).to.be(collection.length);
        return collection.forEach(function(model, index) {
          return expect(visibleItems[index]).to.be(model);
        });
      });
      return it('should fire visibilityChange events', function() {
        var visibilityChange;
        basicSetup([]);
        visibilityChange = sinon.spy();
        collectionView.on('visibilityChange', visibilityChange);
        addOne();
        expect(visibilityChange).was.calledWith(collectionView.visibleItems);
        return expect(collectionView.visibleItems.length).to.be(1);
      });
    });
    describe('Animation', function() {
      var AnimatingCollectionView;
      AnimatingCollectionView = (function(_super) {

        __extends(AnimatingCollectionView, _super);

        function AnimatingCollectionView() {
          return AnimatingCollectionView.__super__.constructor.apply(this, arguments);
        }

        AnimatingCollectionView.prototype.tagName = 'ul';

        AnimatingCollectionView.prototype.animationDuration = 1;

        AnimatingCollectionView.prototype.itemView = ItemView;

        return AnimatingCollectionView;

      })(Mildred.CollectionView);
      it('should animate the opacity of new items', function() {
        var $animate, $css, args;
        $css = sinon.stub(jQuery.prototype, 'css', function() {
          return this;
        });
        $animate = sinon.stub(jQuery.prototype, 'animate', function() {
          return this;
        });
        createCollection();
        collectionView = new AnimatingCollectionView({
          collection: collection
        });
        expect($css.callCount).to.be(collection.length);
        expect($css).was.calledWith('opacity', 0);
        expect($animate.callCount).to.be(collection.length);
        args = $animate.firstCall.args;
        expect(args[0]).to.eql({
          opacity: 1
        });
        expect(args[1]).to.be(collectionView.animationDuration);
        expect($css.calledBefore($animate)).to.be(true);
        addThree();
        expect($css.callCount).to.be(collection.length);
        $css.restore();
        return $animate.restore();
      });
      it('should not animate if animationDuration is 0', function() {
        var $animate, $css;
        $css = sinon.spy(jQuery.prototype, 'css');
        $animate = sinon.spy(jQuery.prototype, 'animate');
        createCollection();
        collectionView = new TestCollectionView({
          collection: collection
        });
        expect($css).was.notCalled();
        expect($animate).was.notCalled();
        addThree();
        expect($css).was.notCalled();
        expect($animate).was.notCalled();
        $css.restore();
        return $animate.restore();
      });
      it('should not animate when re-inserting', function() {
        var $animate, $css, model1, model2, model3;
        $css = sinon.stub(jQuery.prototype, 'css', function() {
          return this;
        });
        $animate = sinon.stub(jQuery.prototype, 'animate', function() {
          return this;
        });
        model1 = new Mildred.Model({
          id: 1
        });
        model2 = new Mildred.Model({
          id: 2
        });
        model3 = new Mildred.Model({
          id: 3
        });
        createCollection([model1, model2]);
        collectionView = new AnimatingCollectionView({
          collection: collection
        });
        expect($css).was.calledTwice();
        expect($animate).was.calledTwice();
        collection.reset([model1, model2, model3]);
        expect($css.callCount).to.be(collection.length);
        expect($animate.callCount).to.be(collection.length);
        $css.restore();
        return $animate.restore();
      });
      it('should animate with CSS classes', function(done) {
        var child, children, _i, _len;
        AnimatingCollectionView = (function(_super) {

          __extends(AnimatingCollectionView, _super);

          function AnimatingCollectionView() {
            return AnimatingCollectionView.__super__.constructor.apply(this, arguments);
          }

          AnimatingCollectionView.prototype.useCssAnimation = true;

          AnimatingCollectionView.prototype.itemView = ItemView;

          return AnimatingCollectionView;

        })(Mildred.CollectionView);
        createCollection();
        collectionView = new AnimatingCollectionView({
          collection: collection
        });
        children = getAllChildren();
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          child = children[_i];
          expect($(child).hasClass('animated-item-view')).to.be["true"];
        }
        return setTimeout(function() {
          var _j, _len1;
          for (_j = 0, _len1 = children.length; _j < _len1; _j++) {
            child = children[_j];
            expect($(child).hasClass('animated-item-view-end')).to.be["true"];
          }
          return done();
        }, 1);
      });
      return it('should animate with custom CSS classes', function(done) {
        var child, children, _i, _len;
        AnimatingCollectionView = (function(_super) {

          __extends(AnimatingCollectionView, _super);

          function AnimatingCollectionView() {
            return AnimatingCollectionView.__super__.constructor.apply(this, arguments);
          }

          AnimatingCollectionView.prototype.useCssAnimation = true;

          AnimatingCollectionView.prototype.animationStartClass = 'a';

          AnimatingCollectionView.prototype.animationEndClass = 'b';

          AnimatingCollectionView.prototype.itemView = ItemView;

          return AnimatingCollectionView;

        })(Mildred.CollectionView);
        createCollection();
        collectionView = new AnimatingCollectionView({
          collection: collection
        });
        children = getAllChildren();
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          child = children[_i];
          expect($(child).hasClass('a')).to.be["true"];
        }
        return setTimeout(function() {
          var _j, _len1;
          for (_j = 0, _len1 = children.length; _j < _len1; _j++) {
            child = children[_j];
            expect($(child).hasClass('b')).to.be["true"];
          }
          return done();
        }, 1);
      });
    });
    describe('Filtering', function() {
      it('should filter views using the filterer', function() {
        var filterer;
        basicSetup();
        filterer = sinon.spy(function(model, position) {
          expect(model).to.be.a(Mildred.Model);
          expect(position).to.be.a('number');
          return true;
        });
        collectionView.filter(filterer);
        return expect(filterer.callCount).to.be(collection.length);
      });
      it('should hide filtered views per default', function() {
        var children;
        basicSetup();
        addThree();
        collectionView.filter(function(model) {
          return model.get('title') === 'new';
        });
        children = getViewChildren();
        return collection.forEach(function(model, index) {
          var $el, displayValue, visible;
          $el = children.eq(index);
          visible = model.get('title') === 'new';
          displayValue = $el.css('display');
          if (visible) {
            return expect(displayValue).not.to.be('none');
          } else {
            return expect(displayValue).to.be('none');
          }
        });
      });
      it('should respect the filterer option', function() {
        var children, filterer;
        createCollection();
        filterer = function(model) {
          return model.id === 'A';
        };
        collectionView = new TestCollectionView({
          collection: collection,
          filterer: filterer
        });
        expect(collectionView.filterer).to.be(filterer);
        expect(collectionView.visibleItems.length).to.be(1);
        children = getViewChildren();
        return expect(children.length).to.be(collection.length);
      });
      it('should remove the filter', function() {
        var children;
        basicSetup();
        addThree();
        collectionView.filter(function(model) {
          return model.get('title') === 'new';
        });
        collectionView.filter(null);
        children = getViewChildren();
        children.each(function(index, element) {
          var displayValue;
          displayValue = jQuery(element).css('display');
          return expect(displayValue).not.to.be('none');
        });
        return expect(collectionView.visibleItems.length).to.be(collection.length);
      });
      it('should save the filterer', function() {
        var filterer;
        basicSetup();
        filterer = function() {
          return false;
        };
        collectionView.filter(filterer);
        expect(collectionView.filterer).to.be(filterer);
        collectionView.filter(null);
        return expect(collectionView.filterer).to.be(null);
      });
      return it('should trigger visibilityChange and update visibleItems', function() {
        var args, visibilityChange;
        basicSetup();
        addThree();
        expect(collectionView.visibleItems.length).to.be(collection.length);
        visibilityChange = sinon.spy();
        collectionView.on('visibilityChange', visibilityChange);
        collectionView.filter(function(model) {
          return model.get('title') === 'new';
        });
        expect(visibilityChange).was.calledOnce();
        args = visibilityChange.firstCall.args;
        expect(args.length).to.be(1);
        expect(args[0]).to.be(collectionView.visibleItems);
        expect(collectionView.visibleItems.length).to.be(3);
        collectionView.filter(null);
        return expect(collectionView.visibleItems.length).to.be(collection.length);
      });
    });
    describe('Filter callback', function() {
      it('should filter views with a callback', function() {
        var call, checkCall, filterCallback, filterCallbackSpy, filterer, index, model, models, startIndex, _i, _len;
        basicSetup();
        filterer = function(model) {
          return model.get('title') === 'new';
        };
        filterCallback = function(view, included) {
          return view.$el.addClass(included ? 'included' : 'not-included');
        };
        filterCallbackSpy = sinon.spy(filterCallback);
        collectionView.filter(filterer, filterCallbackSpy);
        expect(filterCallbackSpy.callCount).to.be(collection.length);
        checkCall = function(model, call) {
          var hasClass, included, view;
          view = collectionView.subview("itemView:" + model.cid);
          included = filterer(model);
          expect(call.calledWith(view, included)).to.be(true);
          hasClass = view.$el.hasClass(included ? 'included' : 'not-included');
          return expect(hasClass).to.be(true);
        };
        collection.forEach(function(model, index) {
          var call;
          call = filterCallbackSpy.getCall(index);
          return checkCall(model, call);
        });
        models = addThree();
        expect(filterCallbackSpy.callCount).to.be(collection.length);
        startIndex = 26;
        for (index = _i = 0, _len = models.length; _i < _len; index = ++_i) {
          model = models[index];
          call = filterCallbackSpy.getCall(startIndex + index);
          checkCall(model, call);
        }
      });
      it('should save the filter callback', function() {
        var filterCallback, filterer;
        basicSetup();
        filterer = function() {
          return false;
        };
        return filterCallback = function() {
          expect(collectionView.filterCallback).to.be(CollectionView.prototype.filterCallback);
          collectionView.filter(filterer, filterCallback);
          return expect(collectionView.filterCallback).to.be(filterCallback);
        };
      });
      return it('should not call the filter callback when unfiltered', function() {
        var spy;
        createCollection([]);
        collectionView = new TestCollectionView({
          collection: collection
        });
        spy = sinon.spy(collectionView, 'filterCallback');
        fillCollection();
        addThree();
        return expect(spy).was.notCalled();
      });
    });
    describe('Disposal', function() {
      return it('should dispose itself correctly', function() {
        var cid, prop, view, viewsByCid, _i, _len, _ref;
        basicSetup();
        expect(collectionView.dispose).to.be.a('function');
        viewsByCid = collectionView.getItemViews();
        expect(collectionView.disposed).to.be(false);
        for (cid in viewsByCid) {
          view = viewsByCid[cid];
          expect(view.disposed).to.be(false);
        }
        collectionView.dispose();
        expect(collectionView.disposed).to.be(true);
        for (cid in viewsByCid) {
          view = viewsByCid[cid];
          expect(view.disposed).to.be(true);
        }
        _ref = ['visibleItems'];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          prop = _ref[_i];
          expect(_.has(collectionView, prop)).to.be(false);
        }
      });
    });
    return describe('Templated CollectionView', function() {
      var TemplatedCollectionView;
      TemplatedCollectionView = (function(_super) {

        __extends(TemplatedCollectionView, _super);

        function TemplatedCollectionView() {
          return TemplatedCollectionView.__super__.constructor.apply(this, arguments);
        }

        TemplatedCollectionView.prototype.fallbackSelector = '> .fallback';

        TemplatedCollectionView.prototype.listSelector = '> ol';

        TemplatedCollectionView.prototype.loadingSelector = '> .loading';

        TemplatedCollectionView.prototype.getTemplateFunction = function() {
          return function() {
            return "<h2>TemplatedCollectionView</h2>\n<ol></ol>\n<p class=\"loading\">Loading…</p>\n<p class=\"fallback\">This list is empty.</p>";
          };
        };

        return TemplatedCollectionView;

      })(TestCollectionView);
      beforeEach(function() {
        createCollection();
        _.extend(collection, Mildred.SyncMachine);
        return collectionView = new TemplatedCollectionView({
          collection: collection
        });
      });
      describe('Template rendering', function() {
        it('should render the template', function() {
          var children;
          children = getAllChildren();
          return expect(children.length).to.be(4);
        });
        return it('should pass the length and the sync status to the template', function() {
          var data;
          data = collectionView.getTemplateData();
          return expect(data).to.eql({
            length: collection.length,
            synced: collection.isSynced()
          });
        });
      });
      describe('Selectors', function() {
        it('should append views to the listSelector', function() {
          var $list, $list2, children;
          $list = collectionView.$list;
          expect($list).to.be.a(jQuery);
          expect($list.length).to.be(1);
          $list2 = collectionView.$(collectionView.listSelector);
          expect($list.get(0)).to.be($list2.get(0));
          children = getViewChildren();
          return expect(children.length).to.be(collection.length);
        });
        return it('should respect the itemSelector property', function() {
          var MixedCollectionView, additionalLength, allChildren, viewChildren;
          MixedCollectionView = (function(_super) {

            __extends(MixedCollectionView, _super);

            function MixedCollectionView() {
              return MixedCollectionView.__super__.constructor.apply(this, arguments);
            }

            MixedCollectionView.prototype.itemSelector = 'li';

            MixedCollectionView.prototype.templateFunction = function(templateData) {
              return "<p>foo</p>\n<div>bar</div>\n<article>qux</article>\n<ul>\n<li>nested</li>\n</ul>";
            };

            MixedCollectionView.prototype.getTemplateFunction = function() {
              return this.templateFunction;
            };

            return MixedCollectionView;

          })(TestCollectionView);
          collectionView.dispose();
          collectionView = new MixedCollectionView({
            collection: collection
          });
          additionalLength = 4;
          allChildren = getAllChildren();
          expect(allChildren.length).to.be(collection.length + additionalLength);
          viewChildren = getViewChildren();
          expect(viewChildren.length).to.be(collection.length);
          expect(allChildren.eq(0).get(0)).to.not.be(viewChildren.get(0));
          return expect(allChildren.eq(additionalLength).get(0)).to.be(viewChildren.get(0));
        });
      });
      describe('Fallback element', function() {
        it('should set the fallback element properly', function() {
          var $fallback, $fallback2;
          $fallback = collectionView.$fallback;
          expect($fallback).to.be.a(jQuery);
          expect($fallback.length).to.be(1);
          $fallback2 = collectionView.$(collectionView.fallbackSelector);
          return expect($fallback.get(0)).to.be($fallback2.get(0));
        });
        it('should show the fallback element properly', function() {
          var $fallback, expectInvisible, expectVisible;
          $fallback = collectionView.$fallback;
          expectVisible = function() {
            return expect($fallback.css('display')).to.be('block');
          };
          expectInvisible = function() {
            return expect($fallback.css('display')).to.be('none');
          };
          collection.unsync();
          expectInvisible();
          collection.beginSync();
          expectInvisible();
          collection.finishSync();
          expectInvisible();
          collection.reset();
          collection.unsync();
          expectInvisible();
          collection.beginSync();
          expectInvisible();
          collection.finishSync();
          expectVisible();
          addOne();
          return expectInvisible();
        });
        return it('should show the fallback after filtering all items', function() {
          var filterer;
          collection.beginSync();
          collection.finishSync();
          filterer = function() {
            return false;
          };
          collectionView.dispose();
          collectionView = new TemplatedCollectionView({
            collection: collection,
            filterer: filterer
          });
          expect(collectionView.filterer).to.be(filterer);
          expect(collectionView.visibleItems.length).to.be(0);
          return expect(collectionView.$fallback.css('display')).to.be('block');
        });
      });
      describe('Loading indicator', function() {
        it('should set the loading indicator properly', function() {
          var $loading, $loading2;
          $loading = collectionView.$loading;
          expect($loading).to.be.a(jQuery);
          expect($loading.length).to.be(1);
          $loading2 = collectionView.$(collectionView.loadingSelector);
          return expect($loading2.get(0)).to.be($loading.get(0));
        });
        return it('should show the loading indicator properly', function() {
          var $loading, expectInvisible, expectVisible;
          $loading = collectionView.$loading;
          expectVisible = function() {
            return expect($loading.css('display')).to.be('block');
          };
          expectInvisible = function() {
            return expect($loading.css('display')).to.be('none');
          };
          collection.unsync();
          expectInvisible();
          collection.beginSync();
          expectInvisible();
          collection.finishSync();
          expectInvisible();
          collection.reset();
          collection.unsync();
          expectInvisible();
          collection.beginSync();
          expectVisible();
          collection.finishSync();
          expectInvisible();
          addOne();
          return expectInvisible();
        });
      });
      describe('Invalid behavior', function() {
        return it('should throw an error of there is no initItemView', function() {
          createCollection();
          return expect(function() {
            return collectionView = new CollectionView({
              collection: collection
            });
          }).to.throwError();
        });
      });
      return describe('Disposal', function() {
        return it('should also dispose when templated', function() {
          var prop, _i, _len, _ref;
          collectionView.dispose();
          _ref = ['$list', '$fallback', '$loading'];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            prop = _ref[_i];
            expect(_.has(collectionView, prop)).to.be(false);
          }
        });
      });
    });
  });

  describe('Layout', function() {
    var createLink, expectWasNotRouted, expectWasRouted, layout, router, testController;
    layout = testController = router = null;
    createLink = function(attributes) {
      var $link, div, link;
      attributes = attributes ? _.clone(attributes) : {};
      if (attributes.href != null) {
        div = document.createElement('div');
        div.innerHTML = "<a href='" + attributes.href + "'>Hello World</a>";
        link = div.firstChild;
        attributes = _.omit(attributes, 'href');
        $link = $(link);
      } else {
        $link = $(document.createElement('a'));
      }
      return $link.attr(attributes);
    };
    expectWasRouted = function(linkAttributes) {
      var passedPath, stub;
      stub = sinon.spy();
      Backbone.on('router:route', stub);
      createLink(linkAttributes).appendTo(document.body).click().remove();
      expect(stub).was.calledOnce();
      passedPath = stub.firstCall.args[0];
      expect(passedPath).to.eql({
        url: linkAttributes.href
      });
      Backbone.off('!router:route', stub);
      return stub;
    };
    expectWasNotRouted = function(linkAttributes) {
      var spy;
      spy = sinon.spy();
      Backbone.on('router:route', spy);
      createLink(linkAttributes).appendTo(document.body).click().remove();
      expect(spy).was.notCalled();
      Backbone.off('!router:route', spy);
      return spy;
    };
    beforeEach(function() {
      layout = new Mildred.Layout({
        title: 'Test Site Title'
      });
      testController = new Mildred.Controller();
      testController.view = new Mildred.View();
      return testController.title = 'Test Controller Title';
    });
    afterEach(function() {
      testController.dispose();
      return layout.dispose();
    });
    it('should have el, $el and $ props / methods', function() {
      expect(layout.el).to.be(document.body);
      return expect(layout.$el).to.be.a($);
    });
    it('should set the document title', function() {
      var spy, title;
      spy = sinon.spy();
      Backbone.on('adjustTitle', spy);
      Backbone.trigger('adjustTitle', testController.title);
      title = "" + testController.title + " \u2013 " + layout.title;
      expect(document.title).to.be(title);
      return expect(spy).was.calledWith(testController.title);
    });
    it('should route clicks on internal links', function() {
      return expectWasRouted({
        href: '/internal/link'
      });
    });
    it('should correctly pass the query string', function() {
      var linkAttributes, passedPath, path, query, stub;
      path = '/internal/link';
      query = 'foo=bar&baz=qux';
      stub = sinon.spy();
      Backbone.on('router:route', stub);
      linkAttributes = {
        href: "" + path + "?" + query
      };
      createLink(linkAttributes).appendTo(document.body).click().remove();
      expect(stub).was.calledOnce();
      passedPath = stub.firstCall.args[0];
      expect(passedPath).to.eql({
        url: linkAttributes.href
      });
      return Backbone.off('!router:route', stub);
    });
    it('should not route links without href attributes', function() {
      return expectWasNotRouted({
        name: 'foo'
      });
    });
    it('should not route links with empty href', function() {
      return expectWasNotRouted({
        href: ''
      });
    });
    it('should not route links to document fragments', function() {
      return expectWasNotRouted({
        href: '#foo'
      });
    });
    it('should not route links with a noscript class', function() {
      return expectWasNotRouted({
        href: '/foo',
        "class": 'noscript'
      });
    });
    it('should not route rel=external links', function() {
      return expectWasNotRouted({
        href: '/foo',
        rel: 'external'
      });
    });
    it('should not route target=blank links', function() {
      return expectWasNotRouted({
        href: '/foo',
        target: '_blank'
      });
    });
    it('should not route non-http(s) links', function() {
      expectWasNotRouted({
        href: 'mailto:a@a.com'
      });
      expectWasNotRouted({
        href: 'javascript:1+1'
      });
      return expectWasNotRouted({
        href: 'tel:1488'
      });
    });
    it('should not route clicks on external links', function() {
      var old;
      old = window.open;
      window.open = sinon.stub();
      expectWasNotRouted({
        href: 'http://example.com/'
      });
      expectWasNotRouted({
        href: 'https://example.com/'
      });
      expect(window.open).was.notCalled();
      return window.open = old;
    });
    it('should route clicks on elements with the “go-to” class', function() {
      var $span, passedPath, path, stub;
      stub = sinon.stub();
      Backbone.on('router:route', stub);
      path = '/internal/link';
      $span = $(document.createElement('span')).addClass('go-to').attr('data-href', path).appendTo(document.body).click().remove();
      expect(stub).was.calledOnce();
      passedPath = stub.firstCall.args[0];
      expect(passedPath).to.eql({
        url: path
      });
      return Backbone.off('!router:route', stub);
    });
    it('custom isExternalLink receives link properties', function() {
      var link, stub;
      stub = sinon.stub().returns(true);
      layout.isExternalLink = stub;
      expectWasNotRouted({
        href: 'http://www.example.org:1234/foo?bar=1#baz',
        target: "_blank",
        rel: "external"
      });
      expect(stub).was.calledOnce();
      link = stub.lastCall.args[0];
      expect(link.target).to.be("_blank");
      expect(link.rel).to.be("external");
      expect(link.hash).to.be("#baz");
      expect(link.pathname.replace(/^\//, '')).to.be("foo");
      return expect(link.host).to.be("www.example.org:1234");
    });
    it('custom isExternalLink should not route if true', function() {
      layout.isExternalLink = function() {
        return true;
      };
      return expectWasNotRouted({
        href: '/foo'
      });
    });
    it('custom isExternalLink should route if false', function() {
      layout.isExternalLink = function() {
        return false;
      };
      return expectWasRouted({
        href: '/foo',
        rel: "external"
      });
    });
    it('routeLinks=false should NOT route clicks on internal links', function() {
      layout.dispose();
      layout = new Mildred.Layout({
        title: '',
        routeLinks: false
      });
      return expectWasNotRouted({
        href: '/internal/link'
      });
    });
    it('openExternalToBlank=true should open external links in a new tab', function() {
      var old;
      old = window.open;
      window.open = sinon.stub();
      layout.dispose();
      layout = new Mildred.Layout({
        title: '',
        openExternalToBlank: true
      });
      expectWasNotRouted({
        href: 'http://www.example.org/'
      });
      expect(window.open).was.called();
      window.open = sinon.stub();
      layout.dispose();
      layout = new Mildred.Layout({
        title: '',
        openExternalToBlank: true
      });
      expectWasNotRouted({
        href: '/foo',
        rel: "external"
      });
      expect(window.open).was.called();
      return window.open = old;
    });
    it('skipRouting=false should route links with a noscript class', function() {
      layout.dispose();
      layout = new Mildred.Layout({
        title: '',
        skipRouting: false
      });
      return expectWasRouted({
        href: '/foo',
        "class": 'noscript'
      });
    });
    it('skipRouting=function should decide whether to route', function() {
      var args, path, stub;
      path = '/foo';
      stub = sinon.stub().returns(false);
      layout.dispose();
      layout = new Mildred.Layout({
        title: '',
        skipRouting: stub
      });
      expectWasNotRouted({
        href: path
      });
      expect(stub).was.calledOnce();
      args = stub.lastCall.args;
      expect(args[0]).to.be(path);
      expect(args[1]).to.be.an('object');
      expect(args[1].nodeName).to.be('A');
      stub = sinon.stub().returns(true);
      layout.dispose();
      layout = new Mildred.Layout({
        title: '',
        skipRouting: stub
      });
      expectWasRouted({
        href: path
      });
      expect(stub).was.calledOnce();
      expect(args[0]).to.be(path);
      expect(args[1]).to.be.an('object');
      return expect(args[1].nodeName).to.be('A');
    });
    it('should dispose itself correctly', function() {
      var spy1, spy2;
      spy1 = sinon.spy();
      layout.on('foo', spy1);
      spy2 = sinon.spy();
      layout.delegateEvents({
        'click #testbed': spy2
      });
      expect(layout.dispose).to.be.a('function');
      layout.dispose();
      expect(layout.disposed).to.be(true);
      layout.trigger('foo');
      $('#testbed').click();
      expect(spy1).was.notCalled();
      return expect(spy2).was.notCalled();
    });
    return it('should be extendable', function() {
      var DerivedLayout, derivedLayout;
      expect(Mildred.Layout.extend).to.be.a('function');
      DerivedLayout = Mildred.Layout.extend();
      derivedLayout = new DerivedLayout();
      expect(derivedLayout).to.be.a(Mildred.Layout);
      return derivedLayout.dispose();
    });
  });

  describe('Controller', function() {
    var controller;
    controller = null;
    beforeEach(function() {
      return controller = new Mildred.Controller();
    });
    afterEach(function() {
      controller.dispose();
      return Backbone.off('router:route');
    });
    it('should mixin a Backbone.Events', function() {
      var name, value, _ref, _results;
      _ref = Backbone.Events;
      _results = [];
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        value = _ref[name];
        _results.push(expect(controller[name]).to.be(Backbone.Events[name]));
      }
      return _results;
    });
    it('should be extendable', function() {
      var DerivedController, derivedController;
      expect(Mildred.Controller.extend).to.be.a('function');
      DerivedController = Mildred.Controller.extend();
      derivedController = new DerivedController();
      expect(derivedController).to.be.a(Mildred.Controller);
      return derivedController.dispose();
    });
    it('should redirect to a URL', function() {
      var routerRoute, url;
      expect(controller.redirectTo).to.be.a('function');
      routerRoute = sinon.spy();
      Backbone.on('router:route', routerRoute);
      url = 'redirect-target/123';
      controller.redirectTo(url);
      expect(controller.redirected).to.be(true);
      return expect(routerRoute).was.calledWith(url);
    });
    it('should redirect to a URL with routing options', function() {
      var options, routerRoute, url;
      routerRoute = sinon.spy();
      Backbone.on('router:route', routerRoute);
      url = 'redirect-target/123';
      options = {
        replace: true
      };
      controller.redirectTo(url, options);
      expect(controller.redirected).to.be(true);
      return expect(routerRoute).was.calledWith(url, options);
    });
    it('should redirect to a named route', function() {
      var name, params, pathDesc, routerRoute;
      routerRoute = sinon.spy();
      Backbone.on('router:route', routerRoute);
      name = 'params';
      params = {
        one: '21'
      };
      pathDesc = {
        name: name,
        params: params
      };
      controller.redirectTo(pathDesc);
      expect(controller.redirected).to.be(true);
      return expect(routerRoute).was.calledWith(pathDesc);
    });
    it('should redirect to a named route with options', function() {
      var name, options, params, pathDesc, routerRoute;
      routerRoute = sinon.spy();
      Backbone.on('router:route', routerRoute);
      name = 'params';
      params = {
        one: '21'
      };
      pathDesc = {
        name: name,
        params: params
      };
      options = {
        replace: true
      };
      controller.redirectTo(pathDesc, options);
      expect(controller.redirected).to.be(true);
      return expect(routerRoute).was.calledWith(pathDesc, options);
    });
    it('should adjust page title', function() {
      var spy;
      spy = sinon.spy();
      Backbone.on('adjustTitle', spy);
      controller.adjustTitle('meh');
      expect(spy).was.calledOnce();
      return expect(spy).was.calledWith('meh');
    });
    return describe('Disposal', function() {
      it('should dispose itself correctly', function() {
        expect(controller.dispose).to.be.a('function');
        controller.dispose();
        return expect(controller.disposed).to.be(true);
      });
      it('should dispose disposable properties', function() {
        var model, view;
        model = controller.model = new Mildred.Model();
        view = controller.view = new Mildred.View({
          model: model
        });
        controller.dispose();
        expect(controller).not.to.have.own.property('model');
        expect(controller).not.to.have.own.property('view');
        expect(model.disposed).to.be(true);
        return expect(view.disposed).to.be(true);
      });
      it('should unsubscribe from Pub/Sub events', function() {
        var pubSubSpy;
        pubSubSpy = sinon.spy();
        controller.on('foo', pubSubSpy);
        controller.dispose();
        controller.trigger('foo');
        return expect(pubSubSpy).was.notCalled();
      });
      return it('should unsubscribe from other events', function() {
        var model, spy;
        spy = sinon.spy();
        model = new Mildred.Model;
        controller.listenTo(model, 'foo', spy);
        controller.dispose();
        model.trigger('foo');
        return expect(spy).was.notCalled();
      });
    });
  });

  describe('Model', function() {
    var model;
    model = null;
    beforeEach(function() {
      return model = new Mildred.Model({
        id: 1
      });
    });
    afterEach(function() {
      return model.dispose();
    });
    it('should return the attributes per default', function() {
      return expect(model.getAttributes()).to.be(model.attributes);
    });
    it('should serialize the attributes', function() {
      var actual, actualCollection, collection, expected, expectedCollection, model1, model2, model3, model4, model5;
      model1 = model.set({
        number: 'one'
      });
      model2 = new Mildred.Model({
        id: 2,
        number: 'two'
      });
      model3 = new Mildred.Model({
        id: 3,
        number: 'three'
      });
      model4 = new Mildred.Model({
        id: 4,
        number: 'four'
      });
      model5 = new Mildred.Model({
        id: 5,
        number: 'five'
      });
      collection = new Backbone.Collection([model4, model5]);
      model1.set({
        model2: model2
      });
      model2.set({
        model3: model3
      });
      model2.set({
        collection: collection
      });
      model2.set({
        model2: model2
      });
      model3.set({
        model2: model2
      });
      model4.set({
        model2: model2
      });
      actual = model.serialize();
      expected = {
        id: 1,
        number: 'one',
        model2: {
          id: 2,
          number: 'two',
          model2: null,
          model3: {
            id: 3,
            number: 'three',
            model2: null
          },
          collection: [
            {
              id: 4,
              number: 'four',
              model2: null
            }, {
              id: 5,
              number: 'five'
            }
          ]
        }
      };
      expect(actual).to.be.an('object');
      expect(actual.number).to.be(expected.number);
      expect(actual.model2).to.be.an('object');
      expect(actual.model2.number).to.be(expected.model2.number);
      expect(actual.model2.model2).to.be(expected.model2.model2);
      actualCollection = actual.model2.collection;
      expectedCollection = expected.model2.collection;
      expect(actualCollection).to.be.an('array');
      expect(actualCollection[0].number).to.be(expectedCollection[0].number);
      expect(actualCollection[0].model2).to.be(expectedCollection[0].model2);
      expect(actualCollection[1].number).to.be(expectedCollection[1].number);
      expect(actual.model2.model3).to.be.an('object');
      expect(actual.model2.model3.number).to.be(expected.model2.model3.number);
      return expect(actual.model2.model3.model2).to.be(expected.model2.model3.model2);
    });
    it('should protect the original attributes when serializing', function() {
      var model1, model2, model3, serialized;
      model1 = model.set({
        number: 'one'
      });
      model2 = new Mildred.Model({
        id: 2,
        number: 'two'
      });
      model3 = new Backbone.Model({
        id: 3,
        number: 'three'
      });
      model1.set({
        model2: model2
      });
      model1.set({
        model3: model3
      });
      serialized = model1.serialize();
      serialized.number = 'new';
      serialized.model2.number = 'new';
      serialized.model3.number = 'new';
      expect(model1.get('number')).to.be('one');
      expect(model2.get('number')).to.be('two');
      return expect(model3.get('number')).to.be('three');
    });
    it('should serialize nested Backbone models and collections', function() {
      var actual, collection, model1, model2, model3;
      model1 = model.set({
        number: 'one'
      });
      model2 = new Mildred.Model({
        id: 2,
        number: 'two'
      });
      model3 = new Backbone.Model({
        id: 3,
        number: 'three'
      });
      collection = new Backbone.Collection([
        new Mildred.Model({
          id: 4,
          number: 'four'
        }), new Backbone.Model({
          id: 5,
          number: 'five'
        })
      ]);
      model1.set({
        model2: model2
      });
      model1.set({
        model3: model3
      });
      model1.set({
        collection: collection
      });
      actual = model1.serialize();
      expect(actual.number).to.be('one');
      expect(actual.model2).to.be.an('object');
      expect(actual.model2.number).to.be('two');
      expect(actual.model3).to.be.an('object');
      expect(actual.model3.number).to.be('three');
      expect(actual.collection).to.be.an('array');
      expect(actual.collection.length).to.be(2);
      expect(actual.collection[0].number).to.be('four');
      return expect(actual.collection[1].number).to.be('five');
    });
    return describe('Disposal', function() {
      it('should dispose itself correctly', function() {
        expect(model.dispose).to.be.a('function');
        model.dispose();
        return expect(model.disposed).to.be(true);
      });
      it('should fire a dispose event', function() {
        var disposeSpy;
        disposeSpy = sinon.spy();
        model.on('dispose', disposeSpy);
        model.dispose();
        return expect(disposeSpy).was.called();
      });
      it('should remove all event handlers from itself', function() {
        var modelBindSpy;
        modelBindSpy = sinon.spy();
        model.on('foo', modelBindSpy);
        model.dispose();
        model.trigger('foo');
        return expect(modelBindSpy).was.notCalled();
      });
      it('should unsubscribe from other events', function() {
        var model2, spy;
        spy = sinon.spy();
        model2 = new Mildred.Model;
        model.listenTo(model2, 'foo', spy);
        model.dispose();
        model2.trigger('foo');
        return expect(spy).was.notCalled();
      });
      return it('should remove instance properties', function() {
        var prop, properties, _i, _len, _results;
        model.dispose();
        properties = ['collection', 'attributes', 'changed', '_escapedAttributes', '_previousAttributes', '_silent', '_pending', '_callbacks'];
        _results = [];
        for (_i = 0, _len = properties.length; _i < _len; _i++) {
          prop = properties[_i];
          _results.push(expect(model).not.to.have.own.property(prop));
        }
        return _results;
      });
    });
  });

  describe('Collection', function() {
    var collection, expectOrder;
    collection = null;
    beforeEach(function() {
      return collection = new Mildred.Collection;
    });
    afterEach(function() {
      return collection.dispose();
    });
    expectOrder = function(order) {
      var id, index, _i, _len, _results;
      _results = [];
      for (index = _i = 0, _len = order.length; _i < _len; index = ++_i) {
        id = order[index];
        _results.push(expect(collection.at(index).id).to.be(id));
      }
      return _results;
    };
    it('should serialize the models', function() {
      var actual, expected, model1, model2;
      model1 = new Mildred.Model({
        id: 1,
        foo: 'foo'
      });
      model2 = new Backbone.Model({
        id: 2,
        bar: 'bar'
      });
      collection = new Mildred.Collection([model1, model2]);
      expect(collection.serialize).to.be.a('function');
      actual = collection.serialize();
      expected = [
        {
          id: 1,
          foo: 'foo'
        }, {
          id: 2,
          bar: 'bar'
        }
      ];
      expect(actual.length).to.be(expected.length);
      expect(actual[0]).to.be.an('object');
      expect(actual[0].id).to.be(expected[0].id);
      expect(actual[0].foo).to.be(expected[0].foo);
      expect(actual[1]).to.be.an('object');
      expect(actual[1].id).to.be(expected[1].id);
      return expect(actual[1].foo).to.be(expected[1].foo);
    });
    return describe('Disposal', function() {
      it('should dispose itself correctly', function() {
        expect(collection.dispose).to.be.a('function');
        collection.dispose();
        expect(collection.length).to.be(0);
        return expect(collection.disposed).to.be(true);
      });
      it('should fire a dispose event', function() {
        var disposeSpy;
        disposeSpy = sinon.spy();
        collection.on('dispose', disposeSpy);
        collection.dispose();
        return expect(disposeSpy).was.called();
      });
      it('should unsubscribe from Pub/Sub events', function() {
        var pubSubSpy;
        pubSubSpy = sinon.spy();
        collection.on('foo', pubSubSpy);
        collection.dispose();
        collection.trigger('foo');
        return expect(pubSubSpy).was.notCalled();
      });
      it('should remove all event handlers from itself', function() {
        var collectionBindSpy;
        collectionBindSpy = sinon.spy();
        collection.on('foo', collectionBindSpy);
        collection.dispose();
        collection.trigger('foo');
        return expect(collectionBindSpy).was.notCalled();
      });
      it('should unsubscribe from other events', function() {
        var model, spy;
        spy = sinon.spy();
        model = new Mildred.Model;
        collection.listenTo(model, 'foo', spy);
        collection.dispose();
        model.trigger('foo');
        return expect(spy).was.notCalled();
      });
      return it('should remove instance properties', function() {
        var prop, _i, _len, _ref, _results;
        collection.dispose();
        _ref = ['model', 'models', '_byId', '_byCid'];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          prop = _ref[_i];
          _results.push(expect(collection).not.to.have.own.property(prop));
        }
        return _results;
      });
    });
  });

}).call(this);
