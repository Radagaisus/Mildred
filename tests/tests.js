// Generated by CoffeeScript 1.4.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  describe('Application', function() {
    var app, getApp;
    app = null;
    getApp = function(noInit) {
      if (noInit) {
        return (function(_super) {

          __extends(_Class, _super);

          function _Class() {
            return _Class.__super__.constructor.apply(this, arguments);
          }

          _Class.prototype.initialize = function() {};

          return _Class;

        })(Mildred.Application);
      } else {
        return Mildred.Application;
      }
    };
    beforeEach(function() {
      return app = new (getApp(true));
    });
    afterEach(function() {
      return app.dispose();
    });
    it('should be a simple object', function() {
      expect(app).to.be.an('object');
      return expect(app).to.be.a(Mildred.Application);
    });
    it('should have initialize function', function() {
      expect(app.initialize).to.be.a('function');
      return app.initialize();
    });
    it('should create a dispatcher', function() {
      expect(app.initDispatcher).to.be.a('function');
      app.initDispatcher();
      return expect(app.dispatcher).to.be.a(Mildred.Dispatcher);
    });
    it('should create a layout', function() {
      expect(app.initLayout).to.be.a('function');
      app.initLayout();
      return expect(app.layout).to.be.a(Mildred.Layout);
    });
    it('should create a composer', function() {
      expect(app.initComposer).to.be.a('function');
      app.initComposer();
      return expect(app.composer).to.be.a(Mildred.Composer);
    });
    it('should create a router', function() {
      var passedMatch, routes, routesCalled;
      passedMatch = null;
      routesCalled = false;
      routes = function(match) {
        routesCalled = true;
        return passedMatch = match;
      };
      expect(app.initRouter).to.be.a('function');
      expect(app.initRouter.length).to.be(2);
      app.initRouter(routes, {
        root: '/',
        pushState: false
      });
      expect(app.router).to.be.a(Mildred.Router);
      expect(routesCalled).to.be(true);
      return expect(passedMatch).to.be.a('function');
    });
    it('should start Backbone.history with start()', function() {
      app.initRouter((function() {}), {
        root: '/',
        pushState: false
      });
      app.start();
      expect(Backbone.History.started).to.be(true);
      return Backbone.history.stop();
    });
    it('should throw an error on double-init', function() {
      return expect(function() {
        return (new (getApp(false))).initialize();
      }).to.throwError();
    });
    it('should dispose itself correctly', function() {
      var prop, _i, _len, _ref;
      expect(app.dispose).to.be.a('function');
      app.dispose();
      _ref = ['dispatcher', 'layout', 'router', 'composer'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        prop = _ref[_i];
        expect(app[prop]).to.be(void 0);
      }
      return expect(app.disposed).to.be(true);
    });
    return it('should be extendable', function() {
      var DerivedApplication, derivedApp;
      app.dispose();
      Backbone.history.stop();
      expect(Mildred.Application.extend).to.be.a('function');
      DerivedApplication = Mildred.Application.extend();
      derivedApp = new DerivedApplication();
      expect(derivedApp).to.be.a(Mildred.Application);
      return derivedApp.dispose();
    });
  });

  describe('SyncMachine', function() {
    var machine;
    machine = null;
    beforeEach(function() {
      machine = {};
      _.extend(machine, Backbone.Events);
      return _.extend(machine, Mildred.SyncMachine);
    });
    it('should change its state', function() {
      expect(machine.syncState()).to.be('unsynced');
      machine.beginSync();
      expect(machine.syncState()).to.be('syncing');
      machine.finishSync();
      expect(machine.syncState()).to.be('synced');
      machine.unsync();
      return expect(machine.syncState()).to.be('unsynced');
    });
    it('should emit sync events', function() {
      var stateChange, synced, syncing, unsynced;
      stateChange = sinon.spy();
      syncing = sinon.spy();
      synced = sinon.spy();
      unsynced = sinon.spy();
      machine.on('syncStateChange', stateChange);
      machine.on('syncing', syncing);
      machine.on('synced', synced);
      machine.on('unsynced', unsynced);
      machine.beginSync();
      expect(stateChange).was.calledOnce();
      expect(stateChange).was.calledWith(machine, 'syncing');
      expect(syncing).was.calledOnce();
      machine.finishSync();
      expect(stateChange).was.calledTwice();
      expect(stateChange).was.calledWith(machine, 'synced');
      return expect(synced).was.calledOnce();
    });
    it('should has shortcuts for checking sync state', function() {
      expect(machine.isUnsynced()).to.be(true);
      expect(machine.isSyncing()).to.be(false);
      expect(machine.isSynced()).to.be(false);
      machine.beginSync();
      expect(machine.isUnsynced()).to.be(false);
      expect(machine.isSyncing()).to.be(true);
      expect(machine.isSynced()).to.be(false);
      machine.finishSync();
      expect(machine.isUnsynced()).to.be(false);
      expect(machine.isSyncing()).to.be(false);
      return expect(machine.isSynced()).to.be(true);
    });
    it('should be able to abort sync', function() {
      machine.beginSync();
      machine.abortSync();
      return expect(machine.syncState()).to.be('unsynced');
    });
    return it('should has sync callbacks', function() {
      var synced, syncing, unsynced;
      syncing = sinon.spy();
      synced = sinon.spy();
      unsynced = sinon.spy();
      machine.syncing(syncing);
      machine.synced(synced);
      machine.unsynced(unsynced);
      machine.beginSync();
      expect(syncing).was.calledOnce();
      machine.finishSync();
      expect(synced).was.calledOnce();
      machine.unsync();
      return expect(unsynced).was.calledTwice();
    });
  });

  describe('View', function() {
    var ConfiguredTestView, TestView, collection, delay, model, renderCalled, setCollection, setModel, template, testbed, view;
    renderCalled = false;
    view = model = collection = null;
    template = '<p>content</p>';
    testbed = document.getElementById('testbed');
    Mildred.templateFunction = _.template;
    beforeEach(function() {
      renderCalled = false;
      return view = new TestView;
    });
    afterEach(function() {
      view.dispose();
      view = null;
      if (model) {
        if (typeof model.dispose === "function") {
          model.dispose();
        }
        model = null;
      }
      if (collection) {
        if (typeof collection.dispose === "function") {
          collection.dispose();
        }
        return collection = null;
      }
    });
    setModel = function() {
      model = new Mildred.Model({
        foo: 'foo',
        bar: 'bar'
      });
      return view.model = model;
    };
    setCollection = function() {
      collection = new Collection;
      return view.collection = collection;
    };
    delay = function(callback) {
      return window.setTimeout(callback, 40);
    };
    TestView = (function(_super) {

      __extends(TestView, _super);

      function TestView() {
        return TestView.__super__.constructor.apply(this, arguments);
      }

      TestView.prototype.id = 'test-view';

      TestView.prototype.initialize = function() {
        return TestView.__super__.initialize.apply(this, arguments);
      };

      TestView.prototype.getTemplateFunction = function() {
        return function() {
          return template;
        };
      };

      TestView.prototype.render = function() {
        TestView.__super__.render.apply(this, arguments);
        return renderCalled = true;
      };

      return TestView;

    })(Mildred.View);
    ConfiguredTestView = (function(_super) {

      __extends(ConfiguredTestView, _super);

      function ConfiguredTestView() {
        return ConfiguredTestView.__super__.constructor.apply(this, arguments);
      }

      ConfiguredTestView.prototype.autoRender = true;

      ConfiguredTestView.prototype.container = '#testbed';

      ConfiguredTestView.prototype.containerMethod = 'before';

      return ConfiguredTestView;

    })(TestView);
    it('should render', function() {
      var renderResult;
      expect(view.render).to.be.a('function');
      renderResult = view.render();
      return expect(renderResult).to.be(view);
    });
    it('should render a template', function() {
      var innerHTML, lowerCaseTemplate;
      view.render();
      innerHTML = view.$el.html().toLowerCase();
      lowerCaseTemplate = template.toLowerCase();
      return expect(innerHTML).to.be(lowerCaseTemplate);
    });
    it('should render automatically', function() {
      view = new TestView({
        autoRender: true
      });
      expect(renderCalled).to.be(true);
      return expect(view.$el.parent().length).to.be(0);
    });
    it('should not render without proper getTemplateFunction', function() {
      return expect(function() {
        return new Mildred.View({
          autoRender: true
        });
      }).to.throwError();
    });
    it('should attach itself to an element automatically', function() {
      view = new TestView({
        container: testbed
      });
      expect(renderCalled).to.be(false);
      expect(view.el.parentNode).to.be(null);
      view.render();
      return expect(view.el.parentNode).to.be(testbed);
    });
    it('should attach itself to a selector automatically', function() {
      view = new TestView({
        container: '#testbed'
      });
      view.render();
      return expect(view.el.parentNode).to.be(testbed);
    });
    it('should attach itself to a jQuery object automatically', function() {
      view = new TestView({
        container: $('#testbed')
      });
      view.render();
      return expect(view.el.parentNode).to.be(testbed);
    });
    it('should use the given attach method', function() {
      view = new TestView({
        container: testbed,
        containerMethod: 'after'
      });
      view.render();
      expect(view.el).to.be(testbed.nextSibling);
      return expect(view.el.parentNode).to.be(testbed.parentNode);
    });
    it('should consider autoRender, container and containerMethod properties', function() {
      view = new ConfiguredTestView();
      expect(renderCalled).to.be(true);
      expect(view.el).to.be(testbed.previousSibling);
      return expect(view.el.parentNode).to.be(testbed.parentNode);
    });
    it('should not attach itself more than once', function() {
      var spy;
      spy = sinon.spy($.prototype, 'append');
      view = new TestView({
        container: testbed
      });
      view.render();
      view.render();
      return expect(spy.calledOnce).to.be(true);
    });
    it('should not attach itself if autoAttach is false', function() {
      var NoAutoAttachView1, NoAutoAttachView2, check, view1, view2;
      NoAutoAttachView1 = (function(_super) {

        __extends(NoAutoAttachView1, _super);

        function NoAutoAttachView1() {
          return NoAutoAttachView1.__super__.constructor.apply(this, arguments);
        }

        NoAutoAttachView1.prototype.autoAttach = false;

        NoAutoAttachView1.prototype.autoRender = true;

        NoAutoAttachView1.prototype.container = testbed;

        NoAutoAttachView1.prototype.getTemplateFunction = TestView.prototype.getTemplateFunction;

        NoAutoAttachView1.prototype.attach = sinon.spy();

        return NoAutoAttachView1;

      })(Mildred.View);
      NoAutoAttachView2 = (function(_super) {

        __extends(NoAutoAttachView2, _super);

        function NoAutoAttachView2() {
          return NoAutoAttachView2.__super__.constructor.apply(this, arguments);
        }

        NoAutoAttachView2.prototype.autoAttach = false;

        NoAutoAttachView2.prototype.autoRender = true;

        NoAutoAttachView2.prototype.container = testbed;

        NoAutoAttachView2.prototype.attach = sinon.spy();

        return NoAutoAttachView2;

      })(TestView);
      check = function(view) {
        var parent;
        parent = view.el.parentNode;
        if (parent) {
          return expect(parent.nodeType).to.be(11);
        } else {
          return expect(parent).to.be(null);
        }
      };
      view1 = new NoAutoAttachView1;
      window.view1 = view1;
      expect(view1.attach).was.notCalled();
      check(view1);
      view2 = new NoAutoAttachView2;
      expect(view2.attach).was.notCalled();
      return check(view2);
    });
    it('should fire an addedToDOM event attching itself to the DOM', function() {
      var spy;
      view = new TestView({
        container: testbed
      });
      spy = sinon.spy();
      view.on('addedToDOM', spy);
      view.render();
      return expect(spy).was.called();
    });
    it('should register and remove user input event handlers', function() {
      var handler, p, spy;
      expect(view.delegate).to.be.a('function');
      expect(view.undelegate).to.be.a('function');
      spy = sinon.spy();
      handler = view.delegate('click', spy);
      expect(handler).to.be.a('function');
      view.$el.trigger('click');
      expect(spy).was.called();
      view.undelegate();
      view.$el.trigger('click');
      expect(spy.callCount).to.be(1);
      view.render();
      spy = sinon.spy();
      handler = view.delegate('click', 'p', spy);
      expect(handler).to.be.a('function');
      p = view.$('p');
      expect(p.length).to.be(1);
      p.trigger('click');
      expect(spy).was.called();
      expect(function() {
        return view.delegate(spy);
      }).to.throwError();
      view.undelegate();
      p.trigger('click');
      return expect(spy.callCount).to.be(1);
    });
    it('should register and remove multiple user input event handlers', function() {
      var handler, spy;
      spy = sinon.spy();
      handler = view.delegate('click keypress', spy);
      view.$el.trigger('click');
      view.$el.trigger('keypress');
      expect(spy).was.calledTwice();
      view.undelegate();
      view.$el.trigger('click');
      view.$el.trigger('keypress');
      return expect(spy).was.calledTwice();
    });
    it('should allow undelegating one event', function() {
      var handler, handler2, spy, spy2;
      spy = sinon.spy();
      spy2 = sinon.spy();
      handler = view.delegate('click keypress', spy);
      handler2 = view.delegate('focusout', spy2);
      view.$el.trigger('click');
      view.$el.trigger('keypress');
      expect(spy).was.calledTwice();
      expect(spy2).was.notCalled();
      view.undelegate('click keypress');
      view.$el.trigger('click');
      view.$el.trigger('keypress');
      view.$el.trigger('focusout');
      expect(spy).was.calledTwice();
      return expect(spy2).was.calledOnce();
    });
    it('should check delegate parameters', function() {
      expect(function() {
        return view.delegate(1, 2, 3);
      }).to.throwError();
      expect(function() {
        return view.delegate('click', 'foo');
      }).to.throwError();
      expect(function() {
        return view.delegate('click', 'foo', 'bar');
      }).to.throwError();
      expect(function() {
        return view.delegate('click', 123);
      }).to.throwError();
      expect(function() {
        return view.delegate('click', (function() {}), 123);
      }).to.throwError();
      return expect(function() {
        return view.delegate('click', 'foo', (function() {}), 'other');
      }).to.throwError();
    });
    it('should correct inheritance of events object', function(done) {
      var A, B, C, D, bcd, d;
      A = (function(_super) {

        __extends(A, _super);

        function A() {
          return A.__super__.constructor.apply(this, arguments);
        }

        A.prototype.autoRender = true;

        A.prototype.getTemplateFunction = function() {
          return function() {
            return '\
              <div id="a"></div>\
              <div id="b"></div>\
              <div id="c"></div>\
              <div id="d"></div>';
          };
        };

        A.prototype.events = {
          'click #a': 'a1Handler'
        };

        A.prototype.a1Handler = sinon.spy();

        A.prototype.click = function(index) {
          return this.$("#" + index).click();
        };

        return A;

      })(TestView);
      B = (function(_super) {

        __extends(B, _super);

        function B() {
          return B.__super__.constructor.apply(this, arguments);
        }

        B.prototype.events = {
          'click #a': 'a2Handler',
          'click #b': 'bHandler'
        };

        B.prototype.a2Handler = sinon.spy();

        B.prototype.bHandler = sinon.spy();

        return B;

      })(A);
      C = (function(_super) {

        __extends(C, _super);

        function C() {
          return C.__super__.constructor.apply(this, arguments);
        }

        C.prototype.events = {
          'click #a': 'a3Handler',
          'click #c': 'cHandler'
        };

        C.prototype.a3Handler = sinon.spy();

        C.prototype.cHandler = sinon.spy();

        return C;

      })(B);
      D = (function(_super) {

        __extends(D, _super);

        function D() {
          return D.__super__.constructor.apply(this, arguments);
        }

        D.prototype.events = {
          'click #a': 'a4Handler',
          'click #d': 'dHandler',
          'click': 'globalHandler'
        };

        D.prototype.a4Handler = sinon.spy();

        D.prototype.dHandler = sinon.spy();

        D.prototype.globalHandler = sinon.spy();

        return D;

      })(C);
      bcd = ['b', 'c', 'd'];
      d = new D;
      d.click('a');
      return delay(function() {
        var index, _i, _j, _len, _len1, _ref;
        _ref = _.range(1, 5);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          index = _ref[_i];
          expect(d["a" + index + "Handler"]).was.calledOnce();
        }
        for (_j = 0, _len1 = bcd.length; _j < _len1; _j++) {
          index = bcd[_j];
          expect(d["" + index + "Handler"]).was.notCalled();
          d.click(index);
        }
        return delay(function() {
          var _k, _len2;
          for (_k = 0, _len2 = bcd.length; _k < _len2; _k++) {
            index = bcd[_k];
            expect(d["" + index + "Handler"]).was.calledOnce();
          }
          expect(d.globalHandler.callCount).to.be(4);
          return done();
        });
      });
    });
    it('should throw an error when function is passed as second arg', function() {
      var E;
      return E = (function(_super) {

        __extends(E, _super);

        function E() {
          return E.__super__.constructor.apply(this, arguments);
        }

        E.prototype.events = function() {
          return expect(function() {
            return new E;
          }).to.throwError();
        };

        return E;

      })(TestView);
    });
    it('should add and return subviews', function() {
      var subview, subview2;
      expect(view.subview).to.be.a('function');
      subview = new Mildred.View();
      view.subview('fooSubview', subview);
      expect(view.subview('fooSubview')).to.be(subview);
      expect(view.subviews.length).to.be(1);
      subview2 = new Mildred.View();
      view.subview('fooSubview', subview2);
      expect(view.subview('fooSubview')).to.be(subview2);
      return expect(view.subviews.length).to.be(1);
    });
    it('should remove subviews', function() {
      var subview;
      expect(view.removeSubview).to.be.a('function');
      subview = new Mildred.View();
      view.subview('fooSubview', subview);
      view.removeSubview('fooSubview');
      expect(typeof view.subview('fooSubview')).to.be('undefined');
      expect(view.subviews.length).to.be(0);
      subview = new Mildred.View();
      view.subview('barSubview', subview);
      view.removeSubview(subview);
      expect(typeof view.subview('barSubview')).to.be('undefined');
      expect(view.subviews.length).to.be(0);
      view.removeSubview('');
      return expect(view.subviews.length).to.be(0);
    });
    it('should return empty template data without a model', function() {
      var templateData;
      templateData = view.getTemplateData();
      expect(templateData).to.be.an('object');
      return expect(_.isEmpty(templateData)).to.be(true);
    });
    it('should return proper template data for a Chaplin model', function() {
      var templateData;
      setModel();
      templateData = view.getTemplateData();
      expect(templateData).to.be.an('object');
      expect(templateData.foo).to.be('foo');
      return expect(templateData.bar).to.be('bar');
    });
    it('should return template data that protects the model', function() {
      var templateData;
      setModel();
      templateData = view.getTemplateData();
      templateData.qux = 'qux';
      return expect(model.get('qux')).to.be(void 0);
    });
    it('should return proper template data for a Backbone model', function() {
      var templateData;
      model = new Backbone.Model({
        foo: 'foo',
        bar: 'bar'
      });
      view.model = model;
      templateData = view.getTemplateData();
      expect(templateData).to.be.an('object');
      expect(templateData.foo).to.be('foo');
      return expect(templateData.bar).to.be('bar');
    });
    it('should return proper template data for Chaplin collections', function() {
      var data, items, model1, model2;
      model1 = new Mildred.Model({
        foo: 'foo'
      });
      model2 = new Mildred.Model({
        bar: 'bar'
      });
      collection = new Mildred.Collection([model1, model2]);
      view.collection = collection;
      data = view.getTemplateData();
      expect(data).to.be.an('object');
      expect(data).to.only.have.keys('items', 'length');
      expect(data.length).to.be(2);
      items = data.items;
      expect(items).to.be.an('array');
      expect(data.length).to.be(items.length);
      expect(items[0]).to.be.an('object');
      expect(items[0].foo).to.be('foo');
      expect(items[1]).to.be.an('object');
      return expect(items[1].bar).to.be('bar');
    });
    it('should return proper template data for Backbone collections', function() {
      var data, items, model1, model2;
      model1 = new Backbone.Model({
        foo: 'foo'
      });
      model2 = new Backbone.Model({
        bar: 'bar'
      });
      collection = new Backbone.Collection([model1, model2]);
      view.collection = collection;
      data = view.getTemplateData();
      expect(data).to.be.an('object');
      expect(data).to.only.have.keys('items', 'length');
      expect(data.length).to.be(2);
      items = data.items;
      expect(items).to.be.an('array');
      expect(items.length).to.be(2);
      expect(items[0]).to.be.an('object');
      expect(items[0].foo).to.be('foo');
      expect(items[1]).to.be.an('object');
      return expect(items[1].bar).to.be('bar');
    });
    it('should add the SyncMachine state to the template data', function() {
      var templateData;
      setModel();
      _.extend(model, Mildred.SyncMachine);
      templateData = view.getTemplateData();
      expect(templateData.synced).to.be(false);
      model.beginSync();
      model.finishSync();
      templateData = view.getTemplateData();
      return expect(templateData.synced).to.be(true);
    });
    it('should not cover existing SyncMachine properties', function() {
      var templateData;
      setModel();
      _.extend(model, Mildred.SyncMachine);
      model.set({
        syncState: 'foo',
        synced: 'bar'
      });
      templateData = view.getTemplateData();
      expect(templateData.syncState).to.be('foo');
      return expect(templateData.synced).to.be('bar');
    });
    describe('Events', function() {
      var EventedView, EventedViewParent;
      EventedViewParent = (function(_super) {

        __extends(EventedViewParent, _super);

        function EventedViewParent() {
          return EventedViewParent.__super__.constructor.apply(this, arguments);
        }

        EventedViewParent.prototype.listen = {
          'ns:a': 'a1Handler',
          'ns:b': function() {
            return this.b1Handler.apply(this, arguments);
          },
          'change:a model': 'a1Handler',
          'change:b model': 'b1Handler',
          'reset collection': 'a1Handler',
          'custom collection': 'b1Handler',
          'ns:a mediator': 'a1Handler',
          'ns:b mediator': 'b1Handler'
        };

        EventedViewParent.prototype.initialize = function() {
          EventedViewParent.__super__.initialize.apply(this, arguments);
          this.a1Handler = sinon.spy();
          return this.b1Handler = sinon.spy();
        };

        return EventedViewParent;

      })(Mildred.View);
      EventedView = (function(_super) {

        __extends(EventedView, _super);

        function EventedView() {
          return EventedView.__super__.constructor.apply(this, arguments);
        }

        EventedView.prototype.listen = {
          'ns:a': 'a2Handler',
          'ns:b': function() {
            return this.b2Handler.apply(this, arguments);
          },
          'change:a model': 'a2Handler',
          'change:b model': 'b2Handler',
          'reset collection': 'a2Handler',
          'custom collection': 'b2Handler',
          'ns:a mediator': 'a2Handler',
          'ns:b mediator': 'b2Handler'
        };

        EventedView.prototype.initialize = function() {
          EventedView.__super__.initialize.apply(this, arguments);
          this.a2Handler = sinon.spy();
          return this.b2Handler = sinon.spy();
        };

        return EventedView;

      })(EventedViewParent);
      it('should bind to own events declaratively', function() {
        view = new EventedView({
          model: new Mildred.Model()
        });
        expect(view.a1Handler).was.notCalled();
        expect(view.a2Handler).was.notCalled();
        expect(view.b1Handler).was.notCalled();
        expect(view.b2Handler).was.notCalled();
        view.trigger('ns:a');
        expect(view.a1Handler).was.calledOnce();
        expect(view.a2Handler).was.calledOnce();
        expect(view.b1Handler).was.notCalled();
        expect(view.b2Handler).was.notCalled();
        view.trigger('ns:b');
        expect(view.a1Handler).was.calledOnce();
        expect(view.a2Handler).was.calledOnce();
        expect(view.b1Handler).was.calledOnce();
        return expect(view.b2Handler).was.calledOnce();
      });
      it('should bind to model events declaratively', function() {
        model = new Mildred.Model();
        view = new EventedView({
          model: model
        });
        expect(view.a1Handler).was.notCalled();
        expect(view.a2Handler).was.notCalled();
        expect(view.b1Handler).was.notCalled();
        expect(view.b2Handler).was.notCalled();
        model.set('a', 1);
        expect(view.a1Handler).was.calledOnce();
        expect(view.a2Handler).was.calledOnce();
        expect(view.b1Handler).was.notCalled();
        expect(view.b2Handler).was.notCalled();
        model.set('b', 2);
        expect(view.a1Handler).was.calledOnce();
        expect(view.a2Handler).was.calledOnce();
        expect(view.b1Handler).was.calledOnce();
        return expect(view.b2Handler).was.calledOnce();
      });
      it('should bind to collection events declaratively', function() {
        collection = new Mildred.Collection();
        view = new EventedView({
          collection: collection
        });
        expect(view.a1Handler).was.notCalled();
        expect(view.a2Handler).was.notCalled();
        expect(view.b1Handler).was.notCalled();
        expect(view.b2Handler).was.notCalled();
        collection.reset([
          {
            a: 1
          }
        ]);
        expect(view.a1Handler).was.calledOnce();
        expect(view.a2Handler).was.calledOnce();
        expect(view.b1Handler).was.notCalled();
        expect(view.b2Handler).was.notCalled();
        collection.trigger('custom');
        expect(view.a1Handler).was.calledOnce();
        expect(view.a2Handler).was.calledOnce();
        expect(view.b1Handler).was.calledOnce();
        return expect(view.b2Handler).was.calledOnce();
      });
      it('should throw an error when corresponding method doesn’t exist', function() {
        var Error2View, ErrorView;
        ErrorView = (function(_super) {

          __extends(ErrorView, _super);

          function ErrorView() {
            return ErrorView.__super__.constructor.apply(this, arguments);
          }

          ErrorView.prototype.listen = {
            'stuff': 'stuff'
          };

          return ErrorView;

        })(Mildred.View);
        Error2View = (function(_super) {

          __extends(Error2View, _super);

          function Error2View() {
            return Error2View.__super__.constructor.apply(this, arguments);
          }

          Error2View.prototype.events = {
            'stuff': 'stuff'
          };

          return Error2View;

        })(ConfiguredTestView);
        expect(function() {
          return new ErrorView;
        }).to.throwError();
        return expect(function() {
          return new Error2View;
        }).to.throwError();
      });
      it('should allow passing params to delegateEvents', function(done) {
        var spy;
        spy = sinon.spy();
        view = new ConfiguredTestView;
        view.delegateEvents({
          'click p': spy
        });
        view.$('p').click();
        return delay(function() {
          expect(spy).was.calledOnce();
          return done();
        });
      });
      it('should register event handlers on the document declaratively', function() {
        var PreservedView, el, spy1, spy2;
        spy1 = sinon.spy();
        spy2 = sinon.spy();
        PreservedView = (function(_super) {

          __extends(PreservedView, _super);

          function PreservedView() {
            return PreservedView.__super__.constructor.apply(this, arguments);
          }

          PreservedView.prototype.autoRender = true;

          PreservedView.prototype.keepElement = true;

          PreservedView.prototype.events = {
            'click p': 'testClickHandler',
            click: spy2
          };

          PreservedView.prototype.testClickHandler = spy1;

          return PreservedView;

        })(TestView);
        view = new PreservedView;
        el = view.$('p');
        el.click();
        expect(spy1).was.called();
        expect(spy2).was.called();
        view.dispose();
        el.click();
        expect(spy1.callCount).to.be(1);
        return expect(spy2.callCount).to.be(1);
      });
      return it('should register event handlers on the document programatically', function() {
        var PreservedView, el, spy1, spy2;
        spy1 = sinon.spy();
        spy2 = sinon.spy();
        PreservedView = (function(_super) {

          __extends(PreservedView, _super);

          function PreservedView() {
            return PreservedView.__super__.constructor.apply(this, arguments);
          }

          PreservedView.prototype.autoRender = true;

          PreservedView.prototype.keepElement = true;

          return PreservedView;

        })(TestView);
        view = new PreservedView;
        view.testClickHandler = spy1;
        view.delegateEvents({
          'click p': 'testClickHandler',
          click: spy2
        });
        el = view.$('p');
        el.click();
        expect(spy1).was.called();
        expect(spy2).was.called();
        view.undelegateEvents();
        el.click();
        expect(spy1.callCount).to.be(1);
        return expect(spy2.callCount).to.be(1);
      });
    });
    it('should pass model attributes to the template function', function() {
      var passedTemplateData, templateData, templateFunc;
      setModel();
      sinon.spy(view, 'getTemplateData');
      passedTemplateData = null;
      templateFunc = sinon.stub().returns(template);
      sinon.stub(view, 'getTemplateFunction').returns(templateFunc);
      view.render();
      expect(view.getTemplateFunction).was.called();
      expect(view.getTemplateData).was.called();
      expect(templateFunc).was.called();
      templateData = templateFunc.lastCall.args[0];
      expect(templateData).to.be.an('object');
      expect(templateData.foo).to.be('foo');
      return expect(templateData.bar).to.be('bar');
    });
    return describe('Disposal', function() {
      it('should dispose itself correctly', function() {
        expect(view.dispose).to.be.a('function');
        view.dispose();
        return expect(view.disposed).to.be(true);
      });
      it('should remove itself from the DOM', function() {
        view.$el.attr('id', 'disposed-view').appendTo(document.body);
        expect($('#disposed-view').length).to.be(1);
        view.dispose();
        return expect($('#disposed-view').length).to.be(0);
      });
      it('should call Backbone.View#remove', function() {
        sinon.spy(view, 'remove');
        view.dispose();
        return expect(view.remove).was.called();
      });
      it('should dispose subviews', function() {
        var subview;
        subview = new Mildred.View();
        sinon.spy(subview, 'dispose');
        view.subview('foo', subview);
        view.dispose();
        expect(subview.disposed).to.be(true);
        return expect(subview.dispose).was.called();
      });
      it('should unsubscribe from Pub/Sub events', function() {
        var spy;
        spy = sinon.spy();
        view.on('foo', spy);
        view.dispose();
        view.trigger('foo');
        return expect(spy).was.notCalled();
      });
      it('should unsubscribe from model events', function() {
        var spy;
        setModel();
        spy = sinon.spy();
        view.listenTo(view.model, 'foo', spy);
        view.dispose();
        model.trigger('foo');
        return expect(spy).was.notCalled();
      });
      it('should remove all event handlers from itself', function() {
        var spy;
        spy = sinon.spy();
        view.on('foo', spy);
        view.dispose();
        view.trigger('foo');
        return expect(spy).was.notCalled();
      });
      it('should remove instance properties', function() {
        var prop, properties, _i, _len, _results;
        view.dispose();
        properties = ['el', '$el', 'options', 'model', 'collection', 'subviews', 'subviewsByName', '_callbacks'];
        _results = [];
        for (_i = 0, _len = properties.length; _i < _len; _i++) {
          prop = properties[_i];
          _results.push(expect(view).not.to.have.own.property(prop));
        }
        return _results;
      });
      it('should dispose itself when the model is disposed', function() {
        model = new Mildred.Model();
        view = new TestView({
          model: model
        });
        model.dispose();
        expect(model.disposed).to.be(true);
        return expect(view.disposed).to.be(true);
      });
      it('should dispose itself when the collection is disposed', function() {
        collection = new Mildred.Collection();
        view = new TestView({
          collection: collection
        });
        collection.dispose();
        expect(collection.disposed).to.be(true);
        return expect(view.disposed).to.be(true);
      });
      it('should not dispose itself when the collection model is disposed', function() {
        collection = new Mildred.Collection([
          {
            a: 1
          }, {
            a: 2
          }, {
            a: 3
          }
        ]);
        view = new TestView({
          collection: collection
        });
        collection.at(0).dispose();
        expect(collection.disposed).to.be(false);
        return expect(view.disposed).to.be(false);
      });
      it('should not render when disposed given render wasn’t overridden', function() {
        var renderResult;
        view = new Mildred.View();
        view.getTemplateFunction = TestView.prototype.getTemplateFunction;
        sinon.spy(view, 'attach');
        renderResult = view.render();
        expect(renderResult).to.be(view);
        view.dispose();
        renderResult = view.render();
        expect(renderResult).to.be(false);
        return expect(view.attach.callCount).to.be(1);
      });
      return it('should not render when disposed given render was overridden', function() {
        var renderResult;
        view = new TestView({
          container: '#testbed'
        });
        sinon.spy(view, 'attach');
        renderResult = view.render();
        expect(renderResult).to.be(view);
        expect(view.attach.callCount).to.be(1);
        expect(renderCalled).to.be(true);
        expect(view.el.parentNode).to.be(testbed);
        view.dispose();
        renderResult = view.render();
        expect(renderResult).to.be(false);
        expect(renderCalled).to.be(true);
        expect($(testbed).children().length).to.be(0);
        return expect(view.attach.callCount).to.be(1);
      });
    });
  });

  describe('Layout', function() {
    var createLink, expectWasNotRouted, expectWasRouted, layout, router, testController;
    layout = testController = router = null;
    createLink = function(attributes) {
      var $link, div, link;
      attributes = attributes ? _.clone(attributes) : {};
      if (attributes.href != null) {
        div = document.createElement('div');
        div.innerHTML = "<a href='" + attributes.href + "'>Hello World</a>";
        link = div.firstChild;
        attributes = _.omit(attributes, 'href');
        $link = $(link);
      } else {
        $link = $(document.createElement('a'));
      }
      return $link.attr(attributes);
    };
    expectWasRouted = function(linkAttributes) {
      var passedPath, stub;
      stub = sinon.spy();
      Backbone.on('router:route', stub);
      createLink(linkAttributes).appendTo(document.body).click().remove();
      expect(stub).was.calledOnce();
      passedPath = stub.firstCall.args[0];
      expect(passedPath).to.eql({
        url: linkAttributes.href
      });
      Backbone.off('!router:route', stub);
      return stub;
    };
    expectWasNotRouted = function(linkAttributes) {
      var spy;
      spy = sinon.spy();
      Backbone.on('router:route', spy);
      createLink(linkAttributes).appendTo(document.body).click().remove();
      expect(spy).was.notCalled();
      Backbone.off('!router:route', spy);
      return spy;
    };
    beforeEach(function() {
      layout = new Mildred.Layout({
        title: 'Test Site Title'
      });
      testController = new Mildred.Controller();
      testController.view = new Mildred.View();
      return testController.title = 'Test Controller Title';
    });
    afterEach(function() {
      testController.dispose();
      return layout.dispose();
    });
    it('should have el, $el and $ props / methods', function() {
      expect(layout.el).to.be(document.body);
      return expect(layout.$el).to.be.a($);
    });
    it('should set the document title', function() {
      var spy, title;
      spy = sinon.spy();
      Backbone.on('adjustTitle', spy);
      Backbone.trigger('adjustTitle', testController.title);
      title = "" + testController.title + " \u2013 " + layout.title;
      expect(document.title).to.be(title);
      return expect(spy).was.calledWith(testController.title);
    });
    it('should route clicks on internal links', function() {
      return expectWasRouted({
        href: '/internal/link'
      });
    });
    it('should correctly pass the query string', function() {
      var linkAttributes, passedPath, path, query, stub;
      path = '/internal/link';
      query = 'foo=bar&baz=qux';
      stub = sinon.spy();
      Backbone.on('router:route', stub);
      linkAttributes = {
        href: "" + path + "?" + query
      };
      createLink(linkAttributes).appendTo(document.body).click().remove();
      expect(stub).was.calledOnce();
      passedPath = stub.firstCall.args[0];
      expect(passedPath).to.eql({
        url: linkAttributes.href
      });
      return Backbone.off('!router:route', stub);
    });
    it('should not route links without href attributes', function() {
      return expectWasNotRouted({
        name: 'foo'
      });
    });
    it('should not route links with empty href', function() {
      return expectWasNotRouted({
        href: ''
      });
    });
    it('should not route links to document fragments', function() {
      return expectWasNotRouted({
        href: '#foo'
      });
    });
    it('should not route links with a noscript class', function() {
      return expectWasNotRouted({
        href: '/foo',
        "class": 'noscript'
      });
    });
    it('should not route rel=external links', function() {
      return expectWasNotRouted({
        href: '/foo',
        rel: 'external'
      });
    });
    it('should not route target=blank links', function() {
      return expectWasNotRouted({
        href: '/foo',
        target: '_blank'
      });
    });
    it('should not route non-http(s) links', function() {
      expectWasNotRouted({
        href: 'mailto:a@a.com'
      });
      expectWasNotRouted({
        href: 'javascript:1+1'
      });
      return expectWasNotRouted({
        href: 'tel:1488'
      });
    });
    it('should not route clicks on external links', function() {
      var old;
      old = window.open;
      window.open = sinon.stub();
      expectWasNotRouted({
        href: 'http://example.com/'
      });
      expectWasNotRouted({
        href: 'https://example.com/'
      });
      expect(window.open).was.notCalled();
      return window.open = old;
    });
    it('should route clicks on elements with the “go-to” class', function() {
      var $span, passedPath, path, stub;
      stub = sinon.stub();
      Backbone.on('router:route', stub);
      path = '/internal/link';
      $span = $(document.createElement('span')).addClass('go-to').attr('data-href', path).appendTo(document.body).click().remove();
      expect(stub).was.calledOnce();
      passedPath = stub.firstCall.args[0];
      expect(passedPath).to.eql({
        url: path
      });
      return Backbone.off('!router:route', stub);
    });
    it('custom isExternalLink receives link properties', function() {
      var link, stub;
      stub = sinon.stub().returns(true);
      layout.isExternalLink = stub;
      expectWasNotRouted({
        href: 'http://www.example.org:1234/foo?bar=1#baz',
        target: "_blank",
        rel: "external"
      });
      expect(stub).was.calledOnce();
      link = stub.lastCall.args[0];
      expect(link.target).to.be("_blank");
      expect(link.rel).to.be("external");
      expect(link.hash).to.be("#baz");
      expect(link.pathname.replace(/^\//, '')).to.be("foo");
      return expect(link.host).to.be("www.example.org:1234");
    });
    it('custom isExternalLink should not route if true', function() {
      layout.isExternalLink = function() {
        return true;
      };
      return expectWasNotRouted({
        href: '/foo'
      });
    });
    it('custom isExternalLink should route if false', function() {
      layout.isExternalLink = function() {
        return false;
      };
      return expectWasRouted({
        href: '/foo',
        rel: "external"
      });
    });
    it('routeLinks=false should NOT route clicks on internal links', function() {
      layout.dispose();
      layout = new Mildred.Layout({
        title: '',
        routeLinks: false
      });
      return expectWasNotRouted({
        href: '/internal/link'
      });
    });
    it('openExternalToBlank=true should open external links in a new tab', function() {
      var old;
      old = window.open;
      window.open = sinon.stub();
      layout.dispose();
      layout = new Mildred.Layout({
        title: '',
        openExternalToBlank: true
      });
      expectWasNotRouted({
        href: 'http://www.example.org/'
      });
      expect(window.open).was.called();
      window.open = sinon.stub();
      layout.dispose();
      layout = new Mildred.Layout({
        title: '',
        openExternalToBlank: true
      });
      expectWasNotRouted({
        href: '/foo',
        rel: "external"
      });
      expect(window.open).was.called();
      return window.open = old;
    });
    it('skipRouting=false should route links with a noscript class', function() {
      layout.dispose();
      layout = new Mildred.Layout({
        title: '',
        skipRouting: false
      });
      return expectWasRouted({
        href: '/foo',
        "class": 'noscript'
      });
    });
    it('skipRouting=function should decide whether to route', function() {
      var args, path, stub;
      path = '/foo';
      stub = sinon.stub().returns(false);
      layout.dispose();
      layout = new Mildred.Layout({
        title: '',
        skipRouting: stub
      });
      expectWasNotRouted({
        href: path
      });
      expect(stub).was.calledOnce();
      args = stub.lastCall.args;
      expect(args[0]).to.be(path);
      expect(args[1]).to.be.an('object');
      expect(args[1].nodeName).to.be('A');
      stub = sinon.stub().returns(true);
      layout.dispose();
      layout = new Mildred.Layout({
        title: '',
        skipRouting: stub
      });
      expectWasRouted({
        href: path
      });
      expect(stub).was.calledOnce();
      expect(args[0]).to.be(path);
      expect(args[1]).to.be.an('object');
      return expect(args[1].nodeName).to.be('A');
    });
    it('should dispose itself correctly', function() {
      var spy1, spy2;
      spy1 = sinon.spy();
      layout.on('foo', spy1);
      spy2 = sinon.spy();
      layout.delegateEvents({
        'click #testbed': spy2
      });
      expect(layout.dispose).to.be.a('function');
      layout.dispose();
      expect(layout.disposed).to.be(true);
      if (Object.isFrozen) {
        expect(Object.isFrozen(layout)).to.be(true);
      }
      layout.trigger('foo');
      $('#testbed').click();
      expect(spy1).was.notCalled();
      return expect(spy2).was.notCalled();
    });
    return it('should be extendable', function() {
      var DerivedLayout, derivedLayout;
      expect(Mildred.Layout.extend).to.be.a('function');
      DerivedLayout = Mildred.Layout.extend();
      derivedLayout = new DerivedLayout();
      expect(derivedLayout).to.be.a(Mildred.Layout);
      return derivedLayout.dispose();
    });
  });

  describe('Controller', function() {
    var controller;
    controller = null;
    beforeEach(function() {
      return controller = new Mildred.Controller();
    });
    afterEach(function() {
      controller.dispose();
      return mediator.removeHandlers(['router:route']);
    });
    it('should mixin a Backbone.Events', function() {
      var name, value, _ref, _results;
      _ref = Backbone.Events;
      _results = [];
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        value = _ref[name];
        _results.push(expect(controller[name]).to.be(Backbone.Events[name]));
      }
      return _results;
    });
    it('should be extendable', function() {
      var DerivedController, derivedController;
      expect(Mildred.Controller.extend).to.be.a('function');
      DerivedController = Mildred.Controller.extend();
      derivedController = new DerivedController();
      expect(derivedController).to.be.a(Mildred.Controller);
      return derivedController.dispose();
    });
    it('should redirect to a URL', function() {
      var routerRoute, url;
      expect(controller.redirectTo).to.be.a('function');
      routerRoute = sinon.spy();
      mediator.setHandler('router:route', routerRoute);
      url = 'redirect-target/123';
      controller.redirectTo(url);
      expect(controller.redirected).to.be(true);
      return expect(routerRoute).was.calledWith(url);
    });
    it('should redirect to a URL with routing options', function() {
      var options, routerRoute, url;
      routerRoute = sinon.spy();
      mediator.setHandler('router:route', routerRoute);
      url = 'redirect-target/123';
      options = {
        replace: true
      };
      controller.redirectTo(url, options);
      expect(controller.redirected).to.be(true);
      return expect(routerRoute).was.calledWith(url, options);
    });
    it('should redirect to a named route', function() {
      var name, params, pathDesc, routerRoute;
      routerRoute = sinon.spy();
      mediator.setHandler('router:route', routerRoute);
      name = 'params';
      params = {
        one: '21'
      };
      pathDesc = {
        name: name,
        params: params
      };
      controller.redirectTo(pathDesc);
      expect(controller.redirected).to.be(true);
      return expect(routerRoute).was.calledWith(pathDesc);
    });
    it('should redirect to a named route with options', function() {
      var name, options, params, pathDesc, routerRoute;
      routerRoute = sinon.spy();
      mediator.setHandler('router:route', routerRoute);
      name = 'params';
      params = {
        one: '21'
      };
      pathDesc = {
        name: name,
        params: params
      };
      options = {
        replace: true
      };
      controller.redirectTo(pathDesc, options);
      expect(controller.redirected).to.be(true);
      return expect(routerRoute).was.calledWith(pathDesc, options);
    });
    it('should adjust page title', function() {
      var spy;
      spy = sinon.spy();
      mediator.setHandler('adjustTitle', spy);
      controller.adjustTitle('meh');
      expect(spy).was.calledOnce();
      return expect(spy).was.calledWith('meh');
    });
    return describe('Disposal', function() {
      mediator.setHandler('region:unregister', function() {});
      it('should dispose itself correctly', function() {
        expect(controller.dispose).to.be.a('function');
        controller.dispose();
        expect(controller.disposed).to.be(true);
        if (Object.isFrozen) {
          return expect(Object.isFrozen(controller)).to.be(true);
        }
      });
      it('should dispose disposable properties', function() {
        var model, view;
        model = controller.model = new Mildred.Model();
        view = controller.view = new Mildred.View({
          model: model
        });
        controller.dispose();
        expect(controller).not.to.have.own.property('model');
        expect(controller).not.to.have.own.property('view');
        expect(model.disposed).to.be(true);
        return expect(view.disposed).to.be(true);
      });
      it('should unsubscribe from Pub/Sub events', function() {
        var pubSubSpy;
        pubSubSpy = sinon.spy();
        controller.subscribeEvent('foo', pubSubSpy);
        controller.dispose();
        mediator.publish('foo');
        return expect(pubSubSpy).was.notCalled();
      });
      return it('should unsubscribe from other events', function() {
        var model, spy;
        spy = sinon.spy();
        model = new Model;
        controller.listenTo(model, 'foo', spy);
        controller.dispose();
        model.trigger('foo');
        return expect(spy).was.notCalled();
      });
    });
  });

  describe('Model', function() {
    var model;
    model = null;
    beforeEach(function() {
      return model = new Mildred.Model({
        id: 1
      });
    });
    afterEach(function() {
      return model.dispose();
    });
    it('should return the attributes per default', function() {
      return expect(model.getAttributes()).to.be(model.attributes);
    });
    it('should serialize the attributes', function() {
      var actual, actualCollection, collection, expected, expectedCollection, model1, model2, model3, model4, model5;
      model1 = model.set({
        number: 'one'
      });
      model2 = new Mildred.Model({
        id: 2,
        number: 'two'
      });
      model3 = new Mildred.Model({
        id: 3,
        number: 'three'
      });
      model4 = new Mildred.Model({
        id: 4,
        number: 'four'
      });
      model5 = new Mildred.Model({
        id: 5,
        number: 'five'
      });
      collection = new Backbone.Collection([model4, model5]);
      model1.set({
        model2: model2
      });
      model2.set({
        model3: model3
      });
      model2.set({
        collection: collection
      });
      model2.set({
        model2: model2
      });
      model3.set({
        model2: model2
      });
      model4.set({
        model2: model2
      });
      actual = model.serialize();
      expected = {
        id: 1,
        number: 'one',
        model2: {
          id: 2,
          number: 'two',
          model2: null,
          model3: {
            id: 3,
            number: 'three',
            model2: null
          },
          collection: [
            {
              id: 4,
              number: 'four',
              model2: null
            }, {
              id: 5,
              number: 'five'
            }
          ]
        }
      };
      expect(actual).to.be.an('object');
      expect(actual.number).to.be(expected.number);
      expect(actual.model2).to.be.an('object');
      expect(actual.model2.number).to.be(expected.model2.number);
      expect(actual.model2.model2).to.be(expected.model2.model2);
      actualCollection = actual.model2.collection;
      expectedCollection = expected.model2.collection;
      expect(actualCollection).to.be.an('array');
      expect(actualCollection[0].number).to.be(expectedCollection[0].number);
      expect(actualCollection[0].model2).to.be(expectedCollection[0].model2);
      expect(actualCollection[1].number).to.be(expectedCollection[1].number);
      expect(actual.model2.model3).to.be.an('object');
      expect(actual.model2.model3.number).to.be(expected.model2.model3.number);
      return expect(actual.model2.model3.model2).to.be(expected.model2.model3.model2);
    });
    it('should protect the original attributes when serializing', function() {
      var model1, model2, model3, serialized;
      model1 = model.set({
        number: 'one'
      });
      model2 = new Mildred.Model({
        id: 2,
        number: 'two'
      });
      model3 = new Backbone.Model({
        id: 3,
        number: 'three'
      });
      model1.set({
        model2: model2
      });
      model1.set({
        model3: model3
      });
      serialized = model1.serialize();
      serialized.number = 'new';
      serialized.model2.number = 'new';
      serialized.model3.number = 'new';
      expect(model1.get('number')).to.be('one');
      expect(model2.get('number')).to.be('two');
      return expect(model3.get('number')).to.be('three');
    });
    it('should serialize nested Backbone models and collections', function() {
      var actual, collection, model1, model2, model3;
      model1 = model.set({
        number: 'one'
      });
      model2 = new Mildred.Model({
        id: 2,
        number: 'two'
      });
      model3 = new Backbone.Model({
        id: 3,
        number: 'three'
      });
      collection = new Backbone.Collection([
        new Mildred.Model({
          id: 4,
          number: 'four'
        }), new Backbone.Model({
          id: 5,
          number: 'five'
        })
      ]);
      model1.set({
        model2: model2
      });
      model1.set({
        model3: model3
      });
      model1.set({
        collection: collection
      });
      actual = model1.serialize();
      expect(actual.number).to.be('one');
      expect(actual.model2).to.be.an('object');
      expect(actual.model2.number).to.be('two');
      expect(actual.model3).to.be.an('object');
      expect(actual.model3.number).to.be('three');
      expect(actual.collection).to.be.an('array');
      expect(actual.collection.length).to.be(2);
      expect(actual.collection[0].number).to.be('four');
      return expect(actual.collection[1].number).to.be('five');
    });
    return describe('Disposal', function() {
      it('should dispose itself correctly', function() {
        expect(model.dispose).to.be.a('function');
        model.dispose();
        expect(model.disposed).to.be(true);
        if (Object.isFrozen) {
          return expect(Object.isFrozen(model)).to.be(true);
        }
      });
      it('should fire a dispose event', function() {
        var disposeSpy;
        disposeSpy = sinon.spy();
        model.on('dispose', disposeSpy);
        model.dispose();
        return expect(disposeSpy).was.called();
      });
      it('should remove all event handlers from itself', function() {
        var modelBindSpy;
        modelBindSpy = sinon.spy();
        model.on('foo', modelBindSpy);
        model.dispose();
        model.trigger('foo');
        return expect(modelBindSpy).was.notCalled();
      });
      it('should unsubscribe from other events', function() {
        var model2, spy;
        spy = sinon.spy();
        model2 = new Mildred.Model;
        model.listenTo(model2, 'foo', spy);
        model.dispose();
        model2.trigger('foo');
        return expect(spy).was.notCalled();
      });
      return it('should remove instance properties', function() {
        var prop, properties, _i, _len, _results;
        model.dispose();
        properties = ['collection', 'attributes', 'changed', '_escapedAttributes', '_previousAttributes', '_silent', '_pending', '_callbacks'];
        _results = [];
        for (_i = 0, _len = properties.length; _i < _len; _i++) {
          prop = properties[_i];
          _results.push(expect(model).not.to.have.own.property(prop));
        }
        return _results;
      });
    });
  });

  describe('Collection', function() {
    var collection, expectOrder;
    collection = null;
    beforeEach(function() {
      return collection = new Mildred.Collection;
    });
    afterEach(function() {
      return collection.dispose();
    });
    expectOrder = function(order) {
      var id, index, _i, _len, _results;
      _results = [];
      for (index = _i = 0, _len = order.length; _i < _len; index = ++_i) {
        id = order[index];
        _results.push(expect(collection.at(index).id).to.be(id));
      }
      return _results;
    };
    it('should serialize the models', function() {
      var actual, expected, model1, model2;
      model1 = new Mildred.Model({
        id: 1,
        foo: 'foo'
      });
      model2 = new Backbone.Model({
        id: 2,
        bar: 'bar'
      });
      collection = new Mildred.Collection([model1, model2]);
      expect(collection.serialize).to.be.a('function');
      actual = collection.serialize();
      expected = [
        {
          id: 1,
          foo: 'foo'
        }, {
          id: 2,
          bar: 'bar'
        }
      ];
      expect(actual.length).to.be(expected.length);
      expect(actual[0]).to.be.an('object');
      expect(actual[0].id).to.be(expected[0].id);
      expect(actual[0].foo).to.be(expected[0].foo);
      expect(actual[1]).to.be.an('object');
      expect(actual[1].id).to.be(expected[1].id);
      return expect(actual[1].foo).to.be(expected[1].foo);
    });
    return describe('Disposal', function() {
      it('should dispose itself correctly', function() {
        expect(collection.dispose).to.be.a('function');
        collection.dispose();
        expect(collection.length).to.be(0);
        expect(collection.disposed).to.be(true);
        if (Object.isFrozen) {
          return expect(Object.isFrozen(collection)).to.be(true);
        }
      });
      it('should fire a dispose event', function() {
        var disposeSpy;
        disposeSpy = sinon.spy();
        collection.on('dispose', disposeSpy);
        collection.dispose();
        return expect(disposeSpy).was.called();
      });
      it('should unsubscribe from Pub/Sub events', function() {
        var pubSubSpy;
        pubSubSpy = sinon.spy();
        collection.on('foo', pubSubSpy);
        collection.dispose();
        collection.trigger('foo');
        return expect(pubSubSpy).was.notCalled();
      });
      it('should remove all event handlers from itself', function() {
        var collectionBindSpy;
        collectionBindSpy = sinon.spy();
        collection.on('foo', collectionBindSpy);
        collection.dispose();
        collection.trigger('foo');
        return expect(collectionBindSpy).was.notCalled();
      });
      it('should unsubscribe from other events', function() {
        var model, spy;
        spy = sinon.spy();
        model = new Mildred.Model;
        collection.listenTo(model, 'foo', spy);
        collection.dispose();
        model.trigger('foo');
        return expect(spy).was.notCalled();
      });
      return it('should remove instance properties', function() {
        var prop, _i, _len, _ref, _results;
        collection.dispose();
        _ref = ['model', 'models', '_byId', '_byCid'];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          prop = _ref[_i];
          _results.push(expect(collection).not.to.have.own.property(prop));
        }
        return _results;
      });
    });
  });

}).call(this);
