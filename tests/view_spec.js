// Generated by CoffeeScript 1.4.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  describe('View', function() {
    var ConfiguredTestView, TestView, collection, delay, model, renderCalled, setCollection, setModel, template, testbed, view;
    renderCalled = false;
    view = model = collection = null;
    template = '<p>content</p>';
    testbed = document.getElementById('testbed');
    Mildred.templateFunction = _.template;
    beforeEach(function() {
      renderCalled = false;
      return view = new TestView;
    });
    afterEach(function() {
      view.dispose();
      view = null;
      if (model) {
        if (typeof model.dispose === "function") {
          model.dispose();
        }
        model = null;
      }
      if (collection) {
        if (typeof collection.dispose === "function") {
          collection.dispose();
        }
        return collection = null;
      }
    });
    setModel = function() {
      model = new Mildred.Model({
        foo: 'foo',
        bar: 'bar'
      });
      return view.model = model;
    };
    setCollection = function() {
      collection = new Collection;
      return view.collection = collection;
    };
    delay = function(callback) {
      return window.setTimeout(callback, 40);
    };
    TestView = (function(_super) {

      __extends(TestView, _super);

      function TestView() {
        return TestView.__super__.constructor.apply(this, arguments);
      }

      TestView.prototype.id = 'test-view';

      TestView.prototype.initialize = function() {
        return TestView.__super__.initialize.apply(this, arguments);
      };

      TestView.prototype.getTemplateFunction = function() {
        return function() {
          return template;
        };
      };

      TestView.prototype.render = function() {
        TestView.__super__.render.apply(this, arguments);
        return renderCalled = true;
      };

      return TestView;

    })(Mildred.View);
    ConfiguredTestView = (function(_super) {

      __extends(ConfiguredTestView, _super);

      function ConfiguredTestView() {
        return ConfiguredTestView.__super__.constructor.apply(this, arguments);
      }

      ConfiguredTestView.prototype.autoRender = true;

      ConfiguredTestView.prototype.container = '#testbed';

      ConfiguredTestView.prototype.containerMethod = 'before';

      return ConfiguredTestView;

    })(TestView);
    it('should render', function() {
      var renderResult;
      expect(view.render).to.be.a('function');
      renderResult = view.render();
      return expect(renderResult).to.be(view);
    });
    it('should render a template', function() {
      var innerHTML, lowerCaseTemplate;
      view.render();
      innerHTML = view.$el.html().toLowerCase();
      lowerCaseTemplate = template.toLowerCase();
      return expect(innerHTML).to.be(lowerCaseTemplate);
    });
    it('should render automatically', function() {
      view = new TestView({
        autoRender: true
      });
      expect(renderCalled).to.be(true);
      return expect(view.$el.parent().length).to.be(0);
    });
    it('should not render without proper getTemplateFunction', function() {
      return expect(function() {
        return new Mildred.View({
          autoRender: true
        });
      }).to.throwError();
    });
    it('should attach itself to an element automatically', function() {
      view = new TestView({
        container: testbed
      });
      expect(renderCalled).to.be(false);
      expect(view.el.parentNode).to.be(null);
      view.render();
      return expect(view.el.parentNode).to.be(testbed);
    });
    it('should attach itself to a selector automatically', function() {
      view = new TestView({
        container: '#testbed'
      });
      view.render();
      return expect(view.el.parentNode).to.be(testbed);
    });
    it('should attach itself to a jQuery object automatically', function() {
      view = new TestView({
        container: $('#testbed')
      });
      view.render();
      return expect(view.el.parentNode).to.be(testbed);
    });
    it('should use the given attach method', function() {
      view = new TestView({
        container: testbed,
        containerMethod: 'after'
      });
      view.render();
      expect(view.el).to.be(testbed.nextSibling);
      return expect(view.el.parentNode).to.be(testbed.parentNode);
    });
    it('should consider autoRender, container and containerMethod properties', function() {
      view = new ConfiguredTestView();
      expect(renderCalled).to.be(true);
      expect(view.el).to.be(testbed.previousSibling);
      return expect(view.el.parentNode).to.be(testbed.parentNode);
    });
    it('should not attach itself more than once', function() {
      var spy;
      spy = sinon.spy($.prototype, 'append');
      view = new TestView({
        container: testbed
      });
      view.render();
      view.render();
      return expect(spy.calledOnce).to.be(true);
    });
    it('should not attach itself if autoAttach is false', function() {
      var NoAutoAttachView1, NoAutoAttachView2, check, view1, view2;
      NoAutoAttachView1 = (function(_super) {

        __extends(NoAutoAttachView1, _super);

        function NoAutoAttachView1() {
          return NoAutoAttachView1.__super__.constructor.apply(this, arguments);
        }

        NoAutoAttachView1.prototype.autoAttach = false;

        NoAutoAttachView1.prototype.autoRender = true;

        NoAutoAttachView1.prototype.container = testbed;

        NoAutoAttachView1.prototype.getTemplateFunction = TestView.prototype.getTemplateFunction;

        NoAutoAttachView1.prototype.attach = sinon.spy();

        return NoAutoAttachView1;

      })(Mildred.View);
      NoAutoAttachView2 = (function(_super) {

        __extends(NoAutoAttachView2, _super);

        function NoAutoAttachView2() {
          return NoAutoAttachView2.__super__.constructor.apply(this, arguments);
        }

        NoAutoAttachView2.prototype.autoAttach = false;

        NoAutoAttachView2.prototype.autoRender = true;

        NoAutoAttachView2.prototype.container = testbed;

        NoAutoAttachView2.prototype.attach = sinon.spy();

        return NoAutoAttachView2;

      })(TestView);
      check = function(view) {
        var parent;
        parent = view.el.parentNode;
        if (parent) {
          return expect(parent.nodeType).to.be(11);
        } else {
          return expect(parent).to.be(null);
        }
      };
      view1 = new NoAutoAttachView1;
      window.view1 = view1;
      expect(view1.attach).was.notCalled();
      check(view1);
      view2 = new NoAutoAttachView2;
      expect(view2.attach).was.notCalled();
      return check(view2);
    });
    it('should fire an addedToDOM event attching itself to the DOM', function() {
      var spy;
      view = new TestView({
        container: testbed
      });
      spy = sinon.spy();
      view.on('addedToDOM', spy);
      view.render();
      return expect(spy).was.called();
    });
    it('should register and remove user input event handlers', function() {
      var handler, p, spy;
      expect(view.delegate).to.be.a('function');
      expect(view.undelegate).to.be.a('function');
      spy = sinon.spy();
      handler = view.delegate('click', spy);
      expect(handler).to.be.a('function');
      view.$el.trigger('click');
      expect(spy).was.called();
      view.undelegate();
      view.$el.trigger('click');
      expect(spy.callCount).to.be(1);
      view.render();
      spy = sinon.spy();
      handler = view.delegate('click', 'p', spy);
      expect(handler).to.be.a('function');
      p = view.$('p');
      expect(p.length).to.be(1);
      p.trigger('click');
      expect(spy).was.called();
      expect(function() {
        return view.delegate(spy);
      }).to.throwError();
      view.undelegate();
      p.trigger('click');
      return expect(spy.callCount).to.be(1);
    });
    it('should register and remove multiple user input event handlers', function() {
      var handler, spy;
      spy = sinon.spy();
      handler = view.delegate('click keypress', spy);
      view.$el.trigger('click');
      view.$el.trigger('keypress');
      expect(spy).was.calledTwice();
      view.undelegate();
      view.$el.trigger('click');
      view.$el.trigger('keypress');
      return expect(spy).was.calledTwice();
    });
    it('should allow undelegating one event', function() {
      var handler, handler2, spy, spy2;
      spy = sinon.spy();
      spy2 = sinon.spy();
      handler = view.delegate('click keypress', spy);
      handler2 = view.delegate('focusout', spy2);
      view.$el.trigger('click');
      view.$el.trigger('keypress');
      expect(spy).was.calledTwice();
      expect(spy2).was.notCalled();
      view.undelegate('click keypress');
      view.$el.trigger('click');
      view.$el.trigger('keypress');
      view.$el.trigger('focusout');
      expect(spy).was.calledTwice();
      return expect(spy2).was.calledOnce();
    });
    it('should check delegate parameters', function() {
      expect(function() {
        return view.delegate(1, 2, 3);
      }).to.throwError();
      expect(function() {
        return view.delegate('click', 'foo');
      }).to.throwError();
      expect(function() {
        return view.delegate('click', 'foo', 'bar');
      }).to.throwError();
      expect(function() {
        return view.delegate('click', 123);
      }).to.throwError();
      expect(function() {
        return view.delegate('click', (function() {}), 123);
      }).to.throwError();
      return expect(function() {
        return view.delegate('click', 'foo', (function() {}), 'other');
      }).to.throwError();
    });
    it('should correct inheritance of events object', function(done) {
      var A, B, C, D, bcd, d;
      A = (function(_super) {

        __extends(A, _super);

        function A() {
          return A.__super__.constructor.apply(this, arguments);
        }

        A.prototype.autoRender = true;

        A.prototype.getTemplateFunction = function() {
          return function() {
            return '\
              <div id="a"></div>\
              <div id="b"></div>\
              <div id="c"></div>\
              <div id="d"></div>';
          };
        };

        A.prototype.events = {
          'click #a': 'a1Handler'
        };

        A.prototype.a1Handler = sinon.spy();

        A.prototype.click = function(index) {
          return this.$("#" + index).click();
        };

        return A;

      })(TestView);
      B = (function(_super) {

        __extends(B, _super);

        function B() {
          return B.__super__.constructor.apply(this, arguments);
        }

        B.prototype.events = {
          'click #a': 'a2Handler',
          'click #b': 'bHandler'
        };

        B.prototype.a2Handler = sinon.spy();

        B.prototype.bHandler = sinon.spy();

        return B;

      })(A);
      C = (function(_super) {

        __extends(C, _super);

        function C() {
          return C.__super__.constructor.apply(this, arguments);
        }

        C.prototype.events = {
          'click #a': 'a3Handler',
          'click #c': 'cHandler'
        };

        C.prototype.a3Handler = sinon.spy();

        C.prototype.cHandler = sinon.spy();

        return C;

      })(B);
      D = (function(_super) {

        __extends(D, _super);

        function D() {
          return D.__super__.constructor.apply(this, arguments);
        }

        D.prototype.events = {
          'click #a': 'a4Handler',
          'click #d': 'dHandler',
          'click': 'globalHandler'
        };

        D.prototype.a4Handler = sinon.spy();

        D.prototype.dHandler = sinon.spy();

        D.prototype.globalHandler = sinon.spy();

        return D;

      })(C);
      bcd = ['b', 'c', 'd'];
      d = new D;
      d.click('a');
      return delay(function() {
        var index, _i, _j, _len, _len1, _ref;
        _ref = _.range(1, 5);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          index = _ref[_i];
          expect(d["a" + index + "Handler"]).was.calledOnce();
        }
        for (_j = 0, _len1 = bcd.length; _j < _len1; _j++) {
          index = bcd[_j];
          expect(d["" + index + "Handler"]).was.notCalled();
          d.click(index);
        }
        return delay(function() {
          var _k, _len2;
          for (_k = 0, _len2 = bcd.length; _k < _len2; _k++) {
            index = bcd[_k];
            expect(d["" + index + "Handler"]).was.calledOnce();
          }
          expect(d.globalHandler.callCount).to.be(4);
          return done();
        });
      });
    });
    it('should throw an error when function is passed as second arg', function() {
      var E;
      return E = (function(_super) {

        __extends(E, _super);

        function E() {
          return E.__super__.constructor.apply(this, arguments);
        }

        E.prototype.events = function() {
          return expect(function() {
            return new E;
          }).to.throwError();
        };

        return E;

      })(TestView);
    });
    it('should add and return subviews', function() {
      var subview, subview2;
      expect(view.subview).to.be.a('function');
      subview = new Mildred.View();
      view.subview('fooSubview', subview);
      expect(view.subview('fooSubview')).to.be(subview);
      expect(view.subviews.length).to.be(1);
      subview2 = new Mildred.View();
      view.subview('fooSubview', subview2);
      expect(view.subview('fooSubview')).to.be(subview2);
      return expect(view.subviews.length).to.be(1);
    });
    it('should remove subviews', function() {
      var subview;
      expect(view.removeSubview).to.be.a('function');
      subview = new Mildred.View();
      view.subview('fooSubview', subview);
      view.removeSubview('fooSubview');
      expect(typeof view.subview('fooSubview')).to.be('undefined');
      expect(view.subviews.length).to.be(0);
      subview = new Mildred.View();
      view.subview('barSubview', subview);
      view.removeSubview(subview);
      expect(typeof view.subview('barSubview')).to.be('undefined');
      expect(view.subviews.length).to.be(0);
      view.removeSubview('');
      return expect(view.subviews.length).to.be(0);
    });
    it('should return empty template data without a model', function() {
      var templateData;
      templateData = view.getTemplateData();
      expect(templateData).to.be.an('object');
      return expect(_.isEmpty(templateData)).to.be(true);
    });
    it('should return proper template data for a Chaplin model', function() {
      var templateData;
      setModel();
      templateData = view.getTemplateData();
      expect(templateData).to.be.an('object');
      expect(templateData.foo).to.be('foo');
      return expect(templateData.bar).to.be('bar');
    });
    it('should return template data that protects the model', function() {
      var templateData;
      setModel();
      templateData = view.getTemplateData();
      templateData.qux = 'qux';
      return expect(model.get('qux')).to.be(void 0);
    });
    it('should return proper template data for a Backbone model', function() {
      var templateData;
      model = new Backbone.Model({
        foo: 'foo',
        bar: 'bar'
      });
      view.model = model;
      templateData = view.getTemplateData();
      expect(templateData).to.be.an('object');
      expect(templateData.foo).to.be('foo');
      return expect(templateData.bar).to.be('bar');
    });
    it('should return proper template data for Chaplin collections', function() {
      var data, items, model1, model2;
      model1 = new Mildred.Model({
        foo: 'foo'
      });
      model2 = new Mildred.Model({
        bar: 'bar'
      });
      collection = new Mildred.Collection([model1, model2]);
      view.collection = collection;
      data = view.getTemplateData();
      expect(data).to.be.an('object');
      expect(data).to.only.have.keys('items', 'length');
      expect(data.length).to.be(2);
      items = data.items;
      expect(items).to.be.an('array');
      expect(data.length).to.be(items.length);
      expect(items[0]).to.be.an('object');
      expect(items[0].foo).to.be('foo');
      expect(items[1]).to.be.an('object');
      return expect(items[1].bar).to.be('bar');
    });
    it('should return proper template data for Backbone collections', function() {
      var data, items, model1, model2;
      model1 = new Backbone.Model({
        foo: 'foo'
      });
      model2 = new Backbone.Model({
        bar: 'bar'
      });
      collection = new Backbone.Collection([model1, model2]);
      view.collection = collection;
      data = view.getTemplateData();
      expect(data).to.be.an('object');
      expect(data).to.only.have.keys('items', 'length');
      expect(data.length).to.be(2);
      items = data.items;
      expect(items).to.be.an('array');
      expect(items.length).to.be(2);
      expect(items[0]).to.be.an('object');
      expect(items[0].foo).to.be('foo');
      expect(items[1]).to.be.an('object');
      return expect(items[1].bar).to.be('bar');
    });
    it('should add the SyncMachine state to the template data', function() {
      var templateData;
      setModel();
      _.extend(model, Mildred.SyncMachine);
      templateData = view.getTemplateData();
      expect(templateData.synced).to.be(false);
      model.beginSync();
      model.finishSync();
      templateData = view.getTemplateData();
      return expect(templateData.synced).to.be(true);
    });
    it('should not cover existing SyncMachine properties', function() {
      var templateData;
      setModel();
      _.extend(model, Mildred.SyncMachine);
      model.set({
        syncState: 'foo',
        synced: 'bar'
      });
      templateData = view.getTemplateData();
      expect(templateData.syncState).to.be('foo');
      return expect(templateData.synced).to.be('bar');
    });
    describe('Events', function() {
      var EventedView, EventedViewParent;
      EventedViewParent = (function(_super) {

        __extends(EventedViewParent, _super);

        function EventedViewParent() {
          return EventedViewParent.__super__.constructor.apply(this, arguments);
        }

        EventedViewParent.prototype.listen = {
          'ns:a': 'a1Handler',
          'ns:b': function() {
            return this.b1Handler.apply(this, arguments);
          },
          'change:a model': 'a1Handler',
          'change:b model': 'b1Handler',
          'reset collection': 'a1Handler',
          'custom collection': 'b1Handler',
          'ns:a mediator': 'a1Handler',
          'ns:b mediator': 'b1Handler'
        };

        EventedViewParent.prototype.initialize = function() {
          EventedViewParent.__super__.initialize.apply(this, arguments);
          this.a1Handler = sinon.spy();
          return this.b1Handler = sinon.spy();
        };

        return EventedViewParent;

      })(Mildred.View);
      EventedView = (function(_super) {

        __extends(EventedView, _super);

        function EventedView() {
          return EventedView.__super__.constructor.apply(this, arguments);
        }

        EventedView.prototype.listen = {
          'ns:a': 'a2Handler',
          'ns:b': function() {
            return this.b2Handler.apply(this, arguments);
          },
          'change:a model': 'a2Handler',
          'change:b model': 'b2Handler',
          'reset collection': 'a2Handler',
          'custom collection': 'b2Handler',
          'ns:a mediator': 'a2Handler',
          'ns:b mediator': 'b2Handler'
        };

        EventedView.prototype.initialize = function() {
          EventedView.__super__.initialize.apply(this, arguments);
          this.a2Handler = sinon.spy();
          return this.b2Handler = sinon.spy();
        };

        return EventedView;

      })(EventedViewParent);
      it('should bind to own events declaratively', function() {
        view = new EventedView({
          model: new Mildred.Model()
        });
        expect(view.a1Handler).was.notCalled();
        expect(view.a2Handler).was.notCalled();
        expect(view.b1Handler).was.notCalled();
        expect(view.b2Handler).was.notCalled();
        view.trigger('ns:a');
        expect(view.a1Handler).was.calledOnce();
        expect(view.a2Handler).was.calledOnce();
        expect(view.b1Handler).was.notCalled();
        expect(view.b2Handler).was.notCalled();
        view.trigger('ns:b');
        expect(view.a1Handler).was.calledOnce();
        expect(view.a2Handler).was.calledOnce();
        expect(view.b1Handler).was.calledOnce();
        return expect(view.b2Handler).was.calledOnce();
      });
      it('should bind to model events declaratively', function() {
        model = new Mildred.Model();
        view = new EventedView({
          model: model
        });
        expect(view.a1Handler).was.notCalled();
        expect(view.a2Handler).was.notCalled();
        expect(view.b1Handler).was.notCalled();
        expect(view.b2Handler).was.notCalled();
        model.set('a', 1);
        expect(view.a1Handler).was.calledOnce();
        expect(view.a2Handler).was.calledOnce();
        expect(view.b1Handler).was.notCalled();
        expect(view.b2Handler).was.notCalled();
        model.set('b', 2);
        expect(view.a1Handler).was.calledOnce();
        expect(view.a2Handler).was.calledOnce();
        expect(view.b1Handler).was.calledOnce();
        return expect(view.b2Handler).was.calledOnce();
      });
      it('should bind to collection events declaratively', function() {
        collection = new Mildred.Collection();
        view = new EventedView({
          collection: collection
        });
        expect(view.a1Handler).was.notCalled();
        expect(view.a2Handler).was.notCalled();
        expect(view.b1Handler).was.notCalled();
        expect(view.b2Handler).was.notCalled();
        collection.reset([
          {
            a: 1
          }
        ]);
        expect(view.a1Handler).was.calledOnce();
        expect(view.a2Handler).was.calledOnce();
        expect(view.b1Handler).was.notCalled();
        expect(view.b2Handler).was.notCalled();
        collection.trigger('custom');
        expect(view.a1Handler).was.calledOnce();
        expect(view.a2Handler).was.calledOnce();
        expect(view.b1Handler).was.calledOnce();
        return expect(view.b2Handler).was.calledOnce();
      });
      it('should throw an error when corresponding method doesn’t exist', function() {
        var Error2View, ErrorView;
        ErrorView = (function(_super) {

          __extends(ErrorView, _super);

          function ErrorView() {
            return ErrorView.__super__.constructor.apply(this, arguments);
          }

          ErrorView.prototype.listen = {
            'stuff': 'stuff'
          };

          return ErrorView;

        })(Mildred.View);
        Error2View = (function(_super) {

          __extends(Error2View, _super);

          function Error2View() {
            return Error2View.__super__.constructor.apply(this, arguments);
          }

          Error2View.prototype.events = {
            'stuff': 'stuff'
          };

          return Error2View;

        })(ConfiguredTestView);
        expect(function() {
          return new ErrorView;
        }).to.throwError();
        return expect(function() {
          return new Error2View;
        }).to.throwError();
      });
      it('should allow passing params to delegateEvents', function(done) {
        var spy;
        spy = sinon.spy();
        view = new ConfiguredTestView;
        view.delegateEvents({
          'click p': spy
        });
        view.$('p').click();
        return delay(function() {
          expect(spy).was.calledOnce();
          return done();
        });
      });
      it('should register event handlers on the document declaratively', function() {
        var PreservedView, el, spy1, spy2;
        spy1 = sinon.spy();
        spy2 = sinon.spy();
        PreservedView = (function(_super) {

          __extends(PreservedView, _super);

          function PreservedView() {
            return PreservedView.__super__.constructor.apply(this, arguments);
          }

          PreservedView.prototype.autoRender = true;

          PreservedView.prototype.keepElement = true;

          PreservedView.prototype.events = {
            'click p': 'testClickHandler',
            click: spy2
          };

          PreservedView.prototype.testClickHandler = spy1;

          return PreservedView;

        })(TestView);
        view = new PreservedView;
        el = view.$('p');
        el.click();
        expect(spy1).was.called();
        expect(spy2).was.called();
        view.dispose();
        el.click();
        expect(spy1.callCount).to.be(1);
        return expect(spy2.callCount).to.be(1);
      });
      return it('should register event handlers on the document programatically', function() {
        var PreservedView, el, spy1, spy2;
        spy1 = sinon.spy();
        spy2 = sinon.spy();
        PreservedView = (function(_super) {

          __extends(PreservedView, _super);

          function PreservedView() {
            return PreservedView.__super__.constructor.apply(this, arguments);
          }

          PreservedView.prototype.autoRender = true;

          PreservedView.prototype.keepElement = true;

          return PreservedView;

        })(TestView);
        view = new PreservedView;
        view.testClickHandler = spy1;
        view.delegateEvents({
          'click p': 'testClickHandler',
          click: spy2
        });
        el = view.$('p');
        el.click();
        expect(spy1).was.called();
        expect(spy2).was.called();
        view.undelegateEvents();
        el.click();
        expect(spy1.callCount).to.be(1);
        return expect(spy2.callCount).to.be(1);
      });
    });
    it('should pass model attributes to the template function', function() {
      var passedTemplateData, templateData, templateFunc;
      setModel();
      sinon.spy(view, 'getTemplateData');
      passedTemplateData = null;
      templateFunc = sinon.stub().returns(template);
      sinon.stub(view, 'getTemplateFunction').returns(templateFunc);
      view.render();
      expect(view.getTemplateFunction).was.called();
      expect(view.getTemplateData).was.called();
      expect(templateFunc).was.called();
      templateData = templateFunc.lastCall.args[0];
      expect(templateData).to.be.an('object');
      expect(templateData.foo).to.be('foo');
      return expect(templateData.bar).to.be('bar');
    });
    return describe('Disposal', function() {
      it('should dispose itself correctly', function() {
        expect(view.dispose).to.be.a('function');
        view.dispose();
        return expect(view.disposed).to.be(true);
      });
      it('should remove itself from the DOM', function() {
        view.$el.attr('id', 'disposed-view').appendTo(document.body);
        expect($('#disposed-view').length).to.be(1);
        view.dispose();
        return expect($('#disposed-view').length).to.be(0);
      });
      it('should call Backbone.View#remove', function() {
        sinon.spy(view, 'remove');
        view.dispose();
        return expect(view.remove).was.called();
      });
      it('should dispose subviews', function() {
        var subview;
        subview = new Mildred.View();
        sinon.spy(subview, 'dispose');
        view.subview('foo', subview);
        view.dispose();
        expect(subview.disposed).to.be(true);
        return expect(subview.dispose).was.called();
      });
      it('should unsubscribe from Pub/Sub events', function() {
        var spy;
        spy = sinon.spy();
        view.on('foo', spy);
        view.dispose();
        view.trigger('foo');
        return expect(spy).was.notCalled();
      });
      it('should unsubscribe from model events', function() {
        var spy;
        setModel();
        spy = sinon.spy();
        view.listenTo(view.model, 'foo', spy);
        view.dispose();
        model.trigger('foo');
        return expect(spy).was.notCalled();
      });
      it('should remove all event handlers from itself', function() {
        var spy;
        spy = sinon.spy();
        view.on('foo', spy);
        view.dispose();
        view.trigger('foo');
        return expect(spy).was.notCalled();
      });
      it('should remove instance properties', function() {
        var prop, properties, _i, _len, _results;
        view.dispose();
        properties = ['el', '$el', 'options', 'model', 'collection', 'subviews', 'subviewsByName', '_callbacks'];
        _results = [];
        for (_i = 0, _len = properties.length; _i < _len; _i++) {
          prop = properties[_i];
          _results.push(expect(view).not.to.have.own.property(prop));
        }
        return _results;
      });
      it('should dispose itself when the model is disposed', function() {
        model = new Mildred.Model();
        view = new TestView({
          model: model
        });
        model.dispose();
        expect(model.disposed).to.be(true);
        return expect(view.disposed).to.be(true);
      });
      it('should dispose itself when the collection is disposed', function() {
        collection = new Mildred.Collection();
        view = new TestView({
          collection: collection
        });
        collection.dispose();
        expect(collection.disposed).to.be(true);
        return expect(view.disposed).to.be(true);
      });
      it('should not dispose itself when the collection model is disposed', function() {
        collection = new Mildred.Collection([
          {
            a: 1
          }, {
            a: 2
          }, {
            a: 3
          }
        ]);
        view = new TestView({
          collection: collection
        });
        collection.at(0).dispose();
        expect(collection.disposed).to.be(false);
        return expect(view.disposed).to.be(false);
      });
      it('should not render when disposed given render wasn’t overridden', function() {
        var renderResult;
        view = new Mildred.View();
        view.getTemplateFunction = TestView.prototype.getTemplateFunction;
        sinon.spy(view, 'attach');
        renderResult = view.render();
        expect(renderResult).to.be(view);
        view.dispose();
        renderResult = view.render();
        expect(renderResult).to.be(false);
        return expect(view.attach.callCount).to.be(1);
      });
      return it('should not render when disposed given render was overridden', function() {
        var renderResult;
        view = new TestView({
          container: '#testbed'
        });
        sinon.spy(view, 'attach');
        renderResult = view.render();
        expect(renderResult).to.be(view);
        expect(view.attach.callCount).to.be(1);
        expect(renderCalled).to.be(true);
        expect(view.el.parentNode).to.be(testbed);
        view.dispose();
        renderResult = view.render();
        expect(renderResult).to.be(false);
        expect(renderCalled).to.be(true);
        expect($(testbed).children().length).to.be(0);
        return expect(view.attach.callCount).to.be(1);
      });
    });
  });

}).call(this);
